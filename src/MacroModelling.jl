module MacroModelling


import DocStringExtensions: FIELDS, SIGNATURES, TYPEDEF, TYPEDSIGNATURES, TYPEDFIELDS
using StatsFuns, SpecialFunctions
import SymPy: @vars, solve, subs, Sym
import ForwardDiff as ‚Ñ± 
import SparseArrays: SparseMatrixCSC, sparse, spzeros, droptol!, sparsevec, spdiagm, findnz#, sparse!
import LinearAlgebra as ‚Ñí
using Optimization, OptimizationNLopt
import BlockTriangularForm
import Subscripts: super, sub
using IterativeSolvers, LinearMaps
using ComponentArrays
# using NamedArrays
using AxisKeys

using RuntimeGeneratedFunctions
RuntimeGeneratedFunctions.init(@__MODULE__)

# Type definitions
Symbol_input = Union{Symbol,Vector{Symbol},Matrix{Symbol},Tuple{Symbol,Vararg{Symbol}}}

# Imports
include("structures.jl")
include("macros.jl")
include("get_functions.jl")
include("plotting.jl")


export @model, @parameters, solve!
export plot_irfs, plot_irf, plot_IRF, plot, plot_simulations
export get_irfs, get_irf, get_IRF, simulate
export get_solution, get_first_order_solution, get_perturbation_solution
export get_steady_state, get_SS, get_non_stochastic_steady_state, get_stochastic_steady_state
export get_moments
export calculate_jacobian, calculate_hessian, calculate_third_order_derivatives
export calculate_first_order_solution, calculate_second_order_solution, calculate_third_order_solution#, calculate_jacobian_manual, calculate_jacobian_sparse, calculate_jacobian_threaded
export calculate_kalman_filter_loglikelihood


# Internal
export irf, girf
# export riccati_forward, block_solver, remove_redundant_SS_vars!, write_parameters_input!


# StatsFuns
norminvcdf(p::Number) = -erfcinv(2*p) * sqrt2
norminv(p::Number) = norminvcdf(p)
pnorm(p::Number) = normcdf(p)
dnorm(p::Number) = normpdf(p)
qnorm(p::Number) = norminvcdf(p)





Base.show(io::IO, ùìÇ::‚Ñ≥) = println(io, 
                "Model: ",ùìÇ.model_name, 
                "\nVariables: ",length(ùìÇ.var),
                "\nShocks: ",length(ùìÇ.exo),
                "\nParameters: ",length(ùìÇ.par),
                "\nAuxiliary variables: ",length(ùìÇ.exo_present) + length(ùìÇ.aux),
                # "\nCalibration equations: ",length(ùìÇ.calibration_equations),
                # "\nVariable bounds (upper,lower,any): ",sum(ùìÇ.upper_bounds .< Inf),", ",sum(ùìÇ.lower_bounds .> -Inf),", ",length(ùìÇ.bounds),
                # "\nNon-stochastic-steady-state found: ",!ùìÇ.solution.NSSS_outdated
                )


function create_symbols_eqs!(ùìÇ::‚Ñ≥)

    # create symbols in module scope
    symbols_in_equation = union(ùìÇ.var,ùìÇ.par,ùìÇ.parameters,ùìÇ.exo,ùìÇ.dynamic_variables)#,ùìÇ.dynamic_variables_future)
    l_bnds = Dict(ùìÇ.bounded_vars .=> ùìÇ.lower_bounds)
    u_bnds = Dict(ùìÇ.bounded_vars .=> ùìÇ.upper_bounds)

    symbols_pos = []
    symbols_neg = []
    # symbols_zero = []
    symbols_none = []

    for symb in symbols_in_equation
        if symb in ùìÇ.bounded_vars
            if l_bnds[symb] >= 0
                push!(symbols_pos, symb)
            elseif u_bnds[symb] <= 0
                push!(symbols_neg, symb)
            # elseif (u_bnds[symb] >= 0) .& (l_bnds[symb] <= 0)
            #     push!(symbols_zero, symb)
            end
        else
            push!(symbols_none, symb)
        end
    end

    expr =  quote
                @vars $(symbols_pos...)  real = true finite = true positive = true
                @vars $(symbols_neg...)  real = true finite = true negative = true 
                # @vars $(symbols_zero...) real = true zero = true
                @vars $(symbols_none...) real = true finite = true 
            end
    eval(expr)

    ùìÇ.symbolics = symbolics(map(x->eval(:($x)),ùìÇ.ss_equations),
                            map(x->eval(:($x)),ùìÇ.dyn_equations),
                            map(x->eval(:($x)),ùìÇ.dyn_equations_future),

                            map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_shift_var_present_list),
                            map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_shift_var_past_list),
                            map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_shift_var_future_list),

                            map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_shift2_var_past_list),

                            map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_var_present_list),
                            map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_var_past_list),
                            map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_var_future_list),
                            map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_ss_list),
                            map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_exo_list),

                            map(x->Set(eval(:([$(x...)]))),ùìÇ.var_present_list),
                            map(x->Set(eval(:([$(x...)]))),ùìÇ.var_past_list),
                            map(x->Set(eval(:([$(x...)]))),ùìÇ.var_future_list),
                            map(x->Set(eval(:([$(x...)]))),ùìÇ.ss_list),

                            map(x->Set(eval(:([$(x...)]))),ùìÇ.var_list),
                            map(x->Set(eval(:([$(x...)]))),ùìÇ.dynamic_variables_list),
                            map(x->Set(eval(:([$(x...)]))),ùìÇ.dynamic_variables_future_list),
                            map(x->Set(eval(:([$(x...)]))),ùìÇ.par_list),

                            map(x->eval(:($x)),ùìÇ.calibration_equations),
                            map(x->eval(:($x)),ùìÇ.calibration_equations_parameters),
                            map(x->eval(:($x)),ùìÇ.parameters),

                            Set(eval(:([$(ùìÇ.var_present...)]))),
                            Set(eval(:([$(ùìÇ.var_past...)]))),
                            Set(eval(:([$(ùìÇ.var_future...)]))),
                            Set(eval(:([$(ùìÇ.var...)]))),

                            map(x->Set(eval(:([$(x...)]))),ùìÇ.ss_calib_list),
                            map(x->Set(eval(:([$(x...)]))),ùìÇ.par_calib_list),

                            [Set() for _ in 1:length(ùìÇ.ss_equations)],
                            [Set() for _ in 1:length(ùìÇ.calibration_equations)],
                            [Set() for _ in 1:length(ùìÇ.ss_equations)],
                            [Set() for _ in 1:length(ùìÇ.calibration_equations)])
end



function remove_redundant_SS_vars!(ùìÇ::‚Ñ≥)
    # solve SS
    if ùìÇ.creator
        create_symbols_eqs!(ùìÇ)
        ùìÇ.creator = false
    end

    # var_remaining_list = ùìÇ.symbolics.var_list

    ss_equations = ùìÇ.symbolics.ss_equations

    # nCalibEqs = length(ùìÇ.symbolics.var_solved_calib_list)
    # nVars = length(ss_equations)

    # check variables which appear in two time periods. they might be redundant in steady state
    redundant_vars = intersect.(
        union.(
            intersect.(ùìÇ.symbolics.var_future_list,ùìÇ.symbolics.var_present_list),
            intersect.(ùìÇ.symbolics.var_future_list,ùìÇ.symbolics.var_past_list),
            intersect.(ùìÇ.symbolics.var_present_list,ùìÇ.symbolics.var_past_list),
            intersect.(ùìÇ.symbolics.ss_list,ùìÇ.symbolics.var_present_list),
            intersect.(ùìÇ.symbolics.ss_list,ùìÇ.symbolics.var_past_list),
            intersect.(ùìÇ.symbolics.ss_list,ùìÇ.symbolics.var_future_list)
        ),
    ùìÇ.symbolics.var_list)
    redundant_idx = getindex(1:length(redundant_vars), (length.(redundant_vars) .> 0) .& (length.(ùìÇ.symbolics.var_list) .> 1))

    for i in redundant_idx
        for var_to_solve in redundant_vars[i]
            soll = try solve(ss_equations[i],var_to_solve)
            catch
            end
            
            if isnothing(soll)
                continue
            end
            
            if length(soll) == 0 || soll == Sym[0] # take out variable if it is redundant from that euation only
                push!(ùìÇ.symbolics.var_redundant_list[i],var_to_solve)
                ss_equations[i] = ss_equations[i].subs(var_to_solve,1)
            end

        end
    end

end




function solve_steady_state!(ùìÇ::‚Ñ≥,symbolic_SS)
    unknowns = union(ùìÇ.symbolics.var,ùìÇ.symbolics.calibration_equations_parameters)

    if length(unknowns) > length(ùìÇ.symbolics.ss_equations) + length(ùìÇ.symbolics.calibration_equations)
        println("Unable to solve steady state. More unknowns than equations.")
    end

    incidence_matrix = fill(0,length(unknowns),length(unknowns))

    eq_list = union(union.(setdiff.(ùìÇ.symbolics.var_list,
                                    ùìÇ.symbolics.var_redundant_list),
                            ùìÇ.symbolics.par_list),
                    union.(ùìÇ.symbolics.ss_calib_list,
                            ùìÇ.symbolics.par_calib_list))


    for i in 1:length(unknowns)
        for k in 1:length(unknowns)
            incidence_matrix[i,k] = collect(unknowns)[i] ‚àà collect(eq_list)[k]
        end
    end

    Q, P, R, nmatch, n_blocks = BlockTriangularForm.order(sparse(incidence_matrix))
    RÃÇ = []
    for i in 1:n_blocks
        [push!(RÃÇ, n_blocks - i + 1) for ii in R[i]:R[i+1] - 1]
    end
    push!(RÃÇ,1)

    vars = hcat(P, RÃÇ)'
    eqs = hcat(Q, RÃÇ)'

    n = n_blocks

    ss_equations = vcat(ùìÇ.symbolics.ss_equations,ùìÇ.symbolics.calibration_equations) .|> Sym
    # println(ss_equations)

    SS_solve_func = []

    atoms_in_equations = Set()
    atoms_in_equations_list = []
    relevant_pars_across = []

    n_block = 1

    while n > 0 
        if length(eqs[:,eqs[2,:] .== n]) == 2
            var_to_solve = collect(unknowns)[vars[:,vars[2,:] .== n][1]]

            soll = try solve(ss_equations[eqs[:,eqs[2,:] .== n][1]],var_to_solve)
            catch
            end

            if isnothing(soll)
                # println("Could not solve single variables case symbolically.")
                println("Failed finding solution symbolically for: ",var_to_solve," in: ",ss_equations[eqs[:,eqs[2,:] .== n][1]])
                # solve numerically
                continue
            elseif soll[1].is_number
                # ss_equations = ss_equations.subs(var_to_solve,soll[1])
                ss_equations = [eq.subs(var_to_solve,soll[1]) for eq in ss_equations]
                
                push!(ùìÇ.solved_vars,Symbol(var_to_solve))
                push!(ùìÇ.solved_vals,Meta.parse(string(soll[1])))
                push!(SS_solve_func,:($(ùìÇ.solved_vars[end]) = $(ùìÇ.solved_vals[end])))
                push!(atoms_in_equations_list,[])
            else

                push!(ùìÇ.solved_vars,Symbol(var_to_solve))
                push!(ùìÇ.solved_vals,Meta.parse(string(soll[1])))
                
                # atoms = reduce(union,soll[1].atoms())
                [push!(atoms_in_equations, a) for a in soll[1].atoms()]
                push!(atoms_in_equations_list, Set(Symbol.(soll[1].atoms())))
                # println(atoms_in_equations)
                # push!(atoms_in_equations, soll[1].atoms())

                push!(SS_solve_func,:($(ùìÇ.solved_vars[end]) = $(ùìÇ.solved_vals[end])))

            end

            # push!(single_eqs,:($(ùìÇ.solved_vars[end]) = $(ùìÇ.solved_vals[end])))
            # solve symbolically
        else

            vars_to_solve = collect(unknowns)[vars[:,vars[2,:] .== n][1,:]]

            # println(var_to_solve)
            # println(Sym(ss_equations[eqs[:,eqs[2,:] .== n][1,:]]))
            eqs_to_solve = ss_equations[eqs[:,eqs[2,:] .== n][1,:]]

            numerical_sol = false
            
            if symbolic_SS
                soll = try solve(Sym(eqs_to_solve),vars_to_solve)
                # soll = try solve(Sym(eqs_to_solve),var_order)#,check=false,force = true,manual=true)
                catch
                end

                # println(soll)
                if isnothing(soll)
                    println("Failed finding solution symbolically for: ",vars_to_solve," in: ",eqs_to_solve,". Solving numerically.")
                    numerical_sol = true
                    # continue
                elseif length(soll) == 0
                    println("Failed finding solution symbolically for: ",vars_to_solve," in: ",eqs_to_solve,". Solving numerically.")
                    numerical_sol = true
                    # continue
                elseif length(intersect(vars_to_solve,reduce(union,map(x->x.atoms(),collect(soll[1]))))) > 0
                    println("Failed finding solution symbolically for: ",vars_to_solve," in: ",eqs_to_solve,". Solving numerically.")
                    numerical_sol = true
                    # println("Could not solve for: ",intersect(var_list,reduce(union,map(x->x.atoms(),solll)))...)
                    # break_ind = true
                    # break
                else
                    println("Solved: ",string.(eqs_to_solve)," for: ",Symbol.(vars_to_solve), " symbolically.")

                    # relevant_pars = reduce(union,vcat(ùìÇ.par_list,ùìÇ.par_calib_list)[eqs[:,eqs[2,:] .== n][1,:]])
                    # relevant_pars = reduce(union,map(x->x.atoms(),collect(soll[1])))
                    atoms = reduce(union,map(x->x.atoms(),collect(soll[1])))
                    # println(atoms)
                    [push!(atoms_in_equations, a) for a in atoms]
                    
                    for k in 1:length(vars_to_solve)
                        push!(ùìÇ.solved_vars,Symbol(vars_to_solve[k]))
                        push!(ùìÇ.solved_vals,Meta.parse(string(soll[1][k]))) #using convert(Expr,x) leads to ugly expressions

                        push!(atoms_in_equations_list, Set(Symbol.(soll[1][k].atoms())))
                        push!(SS_solve_func,:($(ùìÇ.solved_vars[end]) = $(ùìÇ.solved_vals[end])))
                    end
                end


            end
                
            # try symbolically and use numerical if it does not work
            if numerical_sol || !symbolic_SS
                if !symbolic_SS
                    println("Solved: ",string.(eqs_to_solve)," for: ",Symbol.(vars_to_solve), " numerically.")
                end
                push!(ùìÇ.solved_vars,Symbol.(collect(unknowns)[vars[:,vars[2,:] .== n][1,:]]))
                push!(ùìÇ.solved_vals,Meta.parse.(string.(ss_equations[eqs[:,eqs[2,:] .== n][1,:]])))
                
                syms_in_eqs = Set(Symbol.(Sym(ss_equations[eqs[:,eqs[2,:] .== n][1,:]]).atoms()))
                push!(atoms_in_equations_list,setdiff(syms_in_eqs, ùìÇ.solved_vars[end]))

                calib_pars = []
                calib_pars_input = []
                relevant_pars = reduce(union,vcat(ùìÇ.par_list,ùìÇ.par_calib_list)[eqs[:,eqs[2,:] .== n][1,:]])
                relevant_pars_across = union(relevant_pars_across,relevant_pars)
                # println(relevant_pars)
                iii = 1
                for i in 1:length(ùìÇ.parameters) 
                    valss   = ùìÇ.parameter_values[i]
                    parss = ùìÇ.parameters[i]
                    # println(:($parss))
                    if :($parss) ‚àà relevant_pars
                        push!(calib_pars,:($parss = inputs[$iii]))
                        push!(calib_pars_input,:($parss))
                        iii += 1
                        # push!(calib_pars,:($parss = $valss))
                    end
                end


                guess = []
                result = []
                sorted_vars = sort(ùìÇ.solved_vars[end])
                for i in 1:length(sorted_vars) 
                    parss = sorted_vars[i]
                    push!(guess,:($parss = guess[$i]))
                    push!(result,:($parss = sol[$i]))
                end

                other_vars = []
                other_vars_input = []
                other_vars_inverse = []
                other_vrs = intersect(setdiff(union(ùìÇ.var,ùìÇ.calibration_equations_parameters),sorted_vars),syms_in_eqs)
                # println(other_vrs)
                for k in 1:length(other_vrs)
                    # var_idx = [[findfirst(x->x==y,ùìÇ.var) for y in other_vrs[k]]]
                    var_idx = findfirst(x -> x == other_vrs[k], union(ùìÇ.var,ùìÇ.calibration_equations_parameters))
                    push!(other_vars,:($(other_vrs[k]) = inputs[$iii]))
                    push!(other_vars_input,:($(other_vrs[k])))
                    iii += 1
                    push!(other_vars_inverse,:(ùìÇ.SS_init_guess[$var_idx] = $(other_vrs[k])))
                end
                # println(syms_in_eqs)
                # println(other_vars)
                funcs = :(function block(guess::Vector{Float64},inputs::Vector{Float64})
                        $(guess...) 
                        $(calib_pars...) # add those variables which were previously solved and are used in the equations
                        $(other_vars...) # take only those that appear in equations - DONE
                        # $(calib_pars...) # take only those that appear in equations - DONE
                        # $(other_vars...) # add those variables which were previously solved and sare used in the equations
                        # return sum(abs2,[$(ùìÇ.solved_vals[end]...)])
                        return [$(ùìÇ.solved_vals[end]...)]
                    end)

                funcs_optim = :(function block(guess::Vector{Float64},inputs::Vector{Float64})
                    $(guess...) 
                    $(calib_pars...) # add those variables which were previously solved and are used in the equations
                    $(other_vars...) # take only those that appear in equations - DONE
                    # $(calib_pars...) # take only those that appear in equations - DONE
                    # $(other_vars...) # add those variables which were previously solved and sare used in the equations
                    return sum(abs2,[$(ùìÇ.solved_vals[end]...)])
                    # return [$(ùìÇ.solved_vals[end]...)]
                end)
            
                ùìÇ.SS_init_guess = [fill(1,length(ùìÇ.var)); fill(.5, length(ùìÇ.calibration_equations_parameters))]
                
                # WARNING: infinite bounds are transformed to 1e12
                lbs = []
                ubs = []
                
                limit_boundaries = 1e12

                for i in sorted_vars
                    if i ‚àà ùìÇ.bounded_vars
                        push!(lbs,ùìÇ.lower_bounds[i .== ùìÇ.bounded_vars][1] == -Inf ? -limit_boundaries : ùìÇ.lower_bounds[i .== ùìÇ.bounded_vars][1])
                        push!(ubs,ùìÇ.upper_bounds[i .== ùìÇ.bounded_vars][1] ==  Inf ?  limit_boundaries : ùìÇ.upper_bounds[i .== ùìÇ.bounded_vars][1])
                    else
                        push!(lbs,-limit_boundaries)
                        push!(ubs,limit_boundaries)
                    end
                end
                push!(SS_solve_func,:(lbs = [$(lbs...)]))
                push!(SS_solve_func,:(ubs = [$(ubs...)]))
                push!(SS_solve_func,:(ùìÇ.SS_init_guess = initial_guess))
                # push!(SS_solve_func,:($(other_vars_inverse...)))
                push!(SS_solve_func,:(f = OptimizationFunction(ùìÇ.ss_solve_blocks_optim[$(n_block)], Optimization.AutoForwardDiff())))
                # push!(SS_solve_func,:(prob = OptimizationProblem(f, ùìÇ.SS_init_guess, ùìÇ, lb = [$(lbs...)], ub = [$(ubs...)])))
                push!(SS_solve_func,:(inits = max.(lbs,min.(ubs,ùìÇ.SS_init_guess[$([findfirst(x->x==y,union(ùìÇ.var,ùìÇ.calibration_equations_parameters)) for y in sorted_vars])]))))
                
                
                # push!(SS_solve_func,:(ùìÇ.SS_init_guess[$([findfirst(x -> x==y, union(ùìÇ.var,ùìÇ.calibration_equations_parameters)) for y in sorted_vars])] = sol = block_solver([$(calib_pars_input...),$(other_vars_input...)], 
                push!(SS_solve_func,:(sol = block_solver([$(calib_pars_input...),$(other_vars_input...)], 
                        $(n_block), 
                        ùìÇ.ss_solve_blocks[$(n_block)], 
                        ùìÇ.SS_optimizer, 
                        f, 
                        inits, 
                        lbs, 
                        ubs)))
                        
                        push!(SS_solve_func,:($(result...)))            

                push!(ùìÇ.ss_solve_blocks,@RuntimeGeneratedFunction(funcs))
                push!(ùìÇ.ss_solve_blocks_optim,@RuntimeGeneratedFunction(funcs_optim))
                
                n_block += 1
            end
        end
        n -= 1
    end

    unknwns = Symbol.(collect(unknowns))

    parameters_in_equations = []

    for i in 1:length(ùìÇ.parameters) 
        # valss   = ùìÇ.parameter_values[i]
        parss = ùìÇ.parameters[i]
        # println(:($parss))
        if parss ‚àà union(Symbol.(atoms_in_equations),relevant_pars_across)
            push!(parameters_in_equations,:($parss = parameters[$i]))
            # push!(calib_pars,:($parss = $valss))
        end
    end
    
    dependencies = []
    for i in 1:length(atoms_in_equations_list)
        push!(dependencies,ùìÇ.solved_vars[i] => intersect(atoms_in_equations_list[i],union(ùìÇ.var,ùìÇ.parameters)))
    end
    push!(dependencies,:SS_relevant_calibration_parameters => intersect(reduce(union,atoms_in_equations_list),ùìÇ.parameters))
    # print(dependencies)
    ùìÇ.SS_dependencies = dependencies
    # push!(SS_solve_func,:(return [$(unknwns...)]))

    
    dyn_exos = []
    for dex in union(ùìÇ.exo_past,ùìÇ.exo_future)
        push!(dyn_exos,:($dex = 0))
    end

    push!(SS_solve_func,:($(dyn_exos...)))

    push!(SS_solve_func,:(SS_init_guess = ([$(sort(union(ùìÇ.var,ùìÇ.exo_past,ùìÇ.exo_future))...), $(ùìÇ.calibration_equations_parameters...)])))
    # push!(SS_solve_func,:(print(typeof(SS_init_guess))))
    push!(SS_solve_func,:(ùìÇ.SS_init_guess = typeof(SS_init_guess) == Vector{Float64} ? SS_init_guess : ‚Ñ±.value.(SS_init_guess)))
    

    # push!(SS_solve_func,:(return ComponentArray(non_stochastic_steady_state = [$(sort(union(ùìÇ.var,ùìÇ.exo_past,ùìÇ.exo_future))...)], calibrated_parameters = length([$(ùìÇ.calibration_equations_parameters...)]) > 0 ? [$(ùìÇ.calibration_equations_parameters...)] : 0.0)))
    push!(SS_solve_func,:(return ComponentVector([$(sort(union(ùìÇ.var,ùìÇ.exo_past,ùìÇ.exo_future))...), $(ùìÇ.calibration_equations_parameters...)], Axis([sort(union(ùìÇ.exo_present,ùìÇ.var))...,ùìÇ.calibration_equations_parameters...]))))

    solve_exp = :(function solve_SS(parameters::Vector{Real}, initial_guess::Vector{Real}, ùìÇ::‚Ñ≥)
                            $(parameters_in_equations...)
                            $(SS_solve_func...)
                            end)

    # println(solve_exp)

    ùìÇ.SS_solve_func = @RuntimeGeneratedFunction(solve_exp)

    return nothing
end


function block_solver(inputs::Vector{Float64}, 
                        n_block::Int, 
                        ss_solve_blocks::Function, 
                        SS_optimizer, 
                        f::OptimizationFunction, 
                        guess::Vector{Float64}, 
                        lbs::Vector{Float64}, 
                        ubs::Vector{Float64})
    
    prob = OptimizationProblem(f, guess, inputs, lb = lbs, ub = ubs)
    sol = solve(prob, SS_optimizer(), local_maxiters=10000)
    
    if (sol.minimum > eps()) | (sum(abs2,ss_solve_blocks(sol,inputs)) > eps())
                    println("Block: ",n_block," - Solution not found. Trying optimizer: LN_BOBYQA.")
                    sol = solve(prob, NLopt.LN_BOBYQA(), local_maxiters=10000)
                end
    
    if (sol.minimum > eps()) | (sum(abs2,ss_solve_blocks(sol,inputs)) > eps())
        println("Block: ",n_block," - Local solution not found. Trying global solution.")
        sol = solve(prob, NLopt.GD_MLSL_LDS(), local_method = NLopt.LD_LBFGS(), local_maxiters=10000, population = length(ubs))
    end
    
    if (sol.minimum > eps()) | (sum(abs2,ss_solve_blocks(sol,inputs)) > eps())
        println("Block: ",n_block," - No solution found. Trying with positive domain.")
        
        inits = max.(max.(lbs,eps()),min.(ubs,guess))
        prob = OptimizationProblem(f, guess, inits, lb = max.(lbs,eps()), ub = ubs)
        sol = solve(prob, SS_optimizer(), local_maxiters=10000)
    end
    
    if (sol.minimum > eps()) | (sum(abs2,ss_solve_blocks(sol,inputs)) > eps())
        println("Block: ",n_block," - Solution not found. Trying optimizer: L-BFGS.")
        sol = solve(prob, NLopt.LN_BOBYQA() , local_maxiters=10000)
    end
    
    if (sol.minimum > eps()) | (sum(abs2,ss_solve_blocks(sol,inputs)) > eps())
        println("Block: ",n_block," - Local solution not found. Trying global solution.")
        sol = solve(prob, NLopt.GD_MLSL_LDS(), local_method = NLopt.LD_LBFGS(), local_maxiters=10000, population = length(ubs))
    end
    
    if (sol.minimum > eps()) | (sum(abs2,ss_solve_blocks(sol,inputs)) > eps())
        error("Block: ",n_block," - No solution found. Consider changing bounds.")
    end

    return sol.u
end




function block_solver(inputs::Vector{‚Ñ±.Dual{Z,S,N}}, 
    n_block::Int, 
    ss_solve_blocks::Function, 
    SS_optimizer, 
    f::OptimizationFunction, 
    guess::Vector{Float64}, 
    lbs::Vector{Float64}, 
    ubs::Vector{Float64}) where {Z,S,N}

    # unpack: AoS -> SoA
    inp = ‚Ñ±.value.(inputs)

    # you can play with the dimension here, sometimes it makes sense to transpose
    ps = mapreduce(‚Ñ±.partials, hcat, inputs)'

    # get f(vs)
    val = block_solver(inp, 
                        n_block, 
                        ss_solve_blocks, 
                        SS_optimizer, 
                        f, 
                        guess, 
                        lbs, 
                        ubs)

    # get J(f, vs) * ps (cheating). Write your custom rule here
    B = ‚Ñ±.jacobian(x -> ss_solve_blocks(val, x), inp)
    A = ‚Ñ±.jacobian(x -> ss_solve_blocks(x, inp), val)

    jvp = (-A \ B) * ps

    # pack: SoA -> AoS
    return reshape(map(val, eachrow(jvp)) do v, p
        ‚Ñ±.Dual{Z}(v, p...) # Z is the tag
    end,size(val))
end






function solve!(ùìÇ::‚Ñ≥; 
    parameters = nothing, 
    dynamics::Bool = false, 
    algorithm::Symbol = :first_order, 
    symbolic_SS::Bool = false)

    if algorithm == :all_predefined
        algorithm = ùìÇ.solution.algorithm
    elseif algorithm ‚àà [:linear_time_iteration, :dynare, :first_order, :riccati]
        ùìÇ.solution.algorithm = union(ùìÇ.solution.algorithm,[algorithm])
    end


    if !ùìÇ.solution.functions_written 
        remove_redundant_SS_vars!(ùìÇ)
        solve_steady_state!(ùìÇ,symbolic_SS)
        write_functions_mapping!(ùìÇ)
        ùìÇ.solution.functions_written = true
    end

    if !isnothing(parameters)
        write_parameters_input!(ùìÇ,parameters)
    end

    if dynamics
        if ùìÇ.solution.outdated
            if  algorithm ‚àà [:dynare, :riccati, :first_order]
                jacobian = calculate_jacobian(ùìÇ.parameter_values,ùìÇ)
                sol_mat = calculate_first_order_solution(jacobian; T = ùìÇ.timings)
                state_update = function(state::Vector{Float64}, shock::Vector{Float64}) sol_mat * [state[ùìÇ.timings.past_not_future_and_mixed_idx]; shock] end
                
                ùìÇ.solution.perturbation.first_order = perturbation_solution(sol_mat, state_update)

                ùìÇ.solution.non_stochastic_steady_state = get_non_stochastic_steady_state_internal(ùìÇ)
                ùìÇ.solution.NSSS_outdated = false
            end
            if :second_order == algorithm #‚àà ùìÇ.solution.algorithm
                # calculate_second_order_solution!(ùìÇ)
                if length(ùìÇ.solution.perturbation.first_order.solution_matrix) == 0
                    jacobian = calculate_jacobian(ùìÇ.parameter_values,ùìÇ)   

                    sol_mat = calculate_first_order_solution(jacobian; T = ùìÇ.timings)

                    state_update = function(state::Vector{Float64}, shock::Vector{Float64}) sol_mat * [state[ùìÇ.timings.past_not_future_and_mixed_idx]; shock] end
                            
                    ùìÇ.solution.perturbation.first_order = perturbation_solution(sol_mat, state_update)
                    
                    ùìÇ.solution.non_stochastic_steady_state = get_non_stochastic_steady_state_internal(ùìÇ)
                    ùìÇ.solution.NSSS_outdated = false
                end
                jacobian = calculate_jacobian(ùìÇ.parameter_values,ùìÇ)
                hessian = calculate_hessian(ùìÇ.parameter_values,ùìÇ)
                ùêí‚ÇÇ = calculate_second_order_solution(jacobian, 
                                                hessian, 
                                                ùìÇ.solution.perturbation.first_order.solution_matrix; 
                                                T = ùìÇ.timings)

                ùêí‚ÇÅ = [ùìÇ.solution.perturbation.first_order.solution_matrix[:,1:ùìÇ.timings.nPast_not_future_and_mixed] zeros(ùìÇ.timings.nVars) ùìÇ.solution.perturbation.first_order.solution_matrix[:,ùìÇ.timings.nPast_not_future_and_mixed+1:end]]
                
                ùìÇ.solution.perturbation.second_order.solution_matrix = ùêí‚ÇÇ
                ùìÇ.solution.perturbation.second_order.state_update = function(state::Vector{Float64}, shock::Vector{Float64})
                    aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx]
                                1
                                shock]
                    return ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2
                end

                
                state = zeros(ùìÇ.timings.nVars)
                shock = zeros(ùìÇ.timings.nExo)

                delta = 1

                while delta > eps(Float64)
                    aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx,:]
                                1
                                shock]
                    state_tmp =  ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2
                    delta = sum(abs,state_tmp - state)
                    state = state_tmp
                end

                non_stochastic_steady_state = ùìÇ.solution.non_stochastic_steady_state[1:length(ùìÇ.var)]
                ùìÇ.solution.perturbation.second_order.stochastic_steady_state = non_stochastic_steady_state + vec(state)
                ùìÇ.solution.outdated = false
            end
            if :third_order == algorithm #‚àà ùìÇ.solution.algorithm
                # calculate_third_order_solution(ùìÇ)
                # make sure 1st order solution is available
                if length(ùìÇ.solution.perturbation.first_order.solution_matrix) == 0
                    jacobian = calculate_jacobian(ùìÇ.parameter_values,ùìÇ)

                    sol_mat = calculate_first_order_solution(jacobian; T = ùìÇ.timings)

                    state_update = function(state::Vector{Float64}, shock::Vector{Float64}) sol_mat * [state[ùìÇ.timings.past_not_future_and_mixed_idx]; shock] end
                    
                    ùìÇ.solution.perturbation.first_order = perturbation_solution(sol_mat, state_update)

                    ùìÇ.solution.outdated = false
                    
                    ùìÇ.solution.non_stochastic_steady_state = get_non_stochastic_steady_state_internal(ùìÇ)
                    ùìÇ.solution.NSSS_outdated = false
                end

                # make sure 2nd order solution is available
                if length(ùìÇ.solution.perturbation.second_order.solution_matrix) == 0
                    # calculate_second_order_solution(ùìÇ)
                    
                    jacobian = calculate_jacobian(ùìÇ.parameter_values,ùìÇ)
                    hessian = calculate_hessian(ùìÇ.parameter_values,ùìÇ)

                    ùêí‚ÇÇ = calculate_second_order_solution(jacobian, 
                                                        hessian, 
                                                        ùìÇ.solution.perturbation.first_order.solution_matrix; 
                                                        T = ùìÇ.timings)

                    ùêí‚ÇÅ = [ùìÇ.solution.perturbation.first_order.solution_matrix[:,1:ùìÇ.timings.nPast_not_future_and_mixed] zeros(ùìÇ.timings.nVars) ùìÇ.solution.perturbation.first_order.solution_matrix[:,ùìÇ.timings.nPast_not_future_and_mixed+1:end]]
                    
                    ùìÇ.solution.perturbation.second_order.solution_matrix = ùêí‚ÇÇ
                    ùìÇ.solution.perturbation.second_order.state_update = function(state::Vector{Float64}, shock::Vector{Float64})
                        aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx]
                                    1
                                    shock]
                        return ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2
                    end


                    state = zeros(ùìÇ.timings.nVars)
                    shock = zeros(ùìÇ.timings.nExo)

                    delta = 1

                    while delta > eps(Float64)
                        aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx,:]
                                    1
                                    shock]
                        state_tmp =  ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2
                        delta = sum(abs,state_tmp - state)
                        state = state_tmp
                    end
                    non_stochastic_steady_state = ùìÇ.solution.non_stochastic_steady_state[1:length(ùìÇ.var)]
                    ùìÇ.solution.perturbation.second_order.stochastic_steady_state = non_stochastic_steady_state + vec(state)
                    ùìÇ.solution.outdated = false

                end

                jacobian = calculate_jacobian(ùìÇ.parameter_values,ùìÇ)
                hessian = calculate_hessian(ùìÇ.parameter_values,ùìÇ)
                ‚àá‚ÇÉ = calculate_third_order_derivatives(ùìÇ.parameter_values,ùìÇ)

                ùêí‚ÇÉ = calculate_third_order_solution(jacobian, 
                                                        hessian, 
                                                        ‚àá‚ÇÉ, 
                                                        ùìÇ.solution.perturbation.first_order.solution_matrix, 
                                                        ùìÇ.solution.perturbation.second_order.solution_matrix; 
                                                        T = ùìÇ.timings)


                ùêí‚ÇÇ = ùìÇ.solution.perturbation.second_order.solution_matrix
                
                ùêí‚ÇÅ = [ùìÇ.solution.perturbation.first_order.solution_matrix[:,1:ùìÇ.timings.nPast_not_future_and_mixed] zeros(ùìÇ.timings.nVars) ùìÇ.solution.perturbation.first_order.solution_matrix[:,ùìÇ.timings.nPast_not_future_and_mixed+1:end]]
                
                ùìÇ.solution.perturbation.third_order.solution_matrix = ùêí‚ÇÉ
                ùìÇ.solution.perturbation.third_order.state_update = function(state::Vector{Float64}, shock::Vector{Float64})
                    
                    aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx]
                                 1
                                 shock]

                    return ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2 + ùêí‚ÇÉ * ‚Ñí.kron(‚Ñí.kron(aug_state,aug_state),aug_state) / 6
                end

                state = zeros(ùìÇ.timings.nVars)
                shock = zeros(ùìÇ.timings.nExo)

                delta = 1

                while delta > eps(Float64)
                    aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx,:]
                                 1
                                 shock]

                    state_tmp =  ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2 + ùêí‚ÇÉ * ‚Ñí.kron(‚Ñí.kron(aug_state,aug_state),aug_state) / 6
                    delta = sum(abs,state_tmp - state)
                    state = state_tmp
                end
                non_stochastic_steady_state = ùìÇ.solution.non_stochastic_steady_state[1:length(ùìÇ.var)]
                ùìÇ.solution.perturbation.third_order.stochastic_steady_state = non_stochastic_steady_state + vec(state)
                ùìÇ.solution.outdated = false

            end
            if :linear_time_iteration == algorithm #‚àà ùìÇ.solution.algorithm
                jacobian = calculate_jacobian(ùìÇ.parameter_values,ùìÇ)
                sol_mat = calculate_linear_time_iteration_solution(jacobian; T = ùìÇ.timings)
                state_update = function(state::Vector{Float64}, shock::Vector{Float64}) sol_mat * [state[ùìÇ.timings.past_not_future_and_mixed_idx]; shock] end
                
                ùìÇ.solution.perturbation.linear_time_iteration = perturbation_solution(sol_mat, state_update)
                
                ùìÇ.solution.non_stochastic_steady_state = get_non_stochastic_steady_state_internal(ùìÇ)
                ùìÇ.solution.NSSS_outdated = false
            end
            if length(intersect(ùìÇ.solution.algorithm,[:linear_time_iteration, :dynare, :riccati, :first_order])) == 0
                println("Algorithm to solve dynamics not found.")
            end
        end
        if length(ùìÇ.solution.perturbation.linear_time_iteration.solution_matrix) == 0 && :linear_time_iteration == algorithm #‚àà ùìÇ.solution.algorithm
                jacobian = calculate_jacobian(ùìÇ.parameter_values,ùìÇ)
                sol_mat = calculate_linear_time_iteration_solution(jacobian; T = ùìÇ.timings)
                state_update = function(state::Vector{Float64}, shock::Vector{Float64}) sol_mat * [state[ùìÇ.timings.past_not_future_and_mixed_idx]; shock] end
                
                ùìÇ.solution.perturbation.linear_time_iteration = perturbation_solution(sol_mat, state_update)
                
                ùìÇ.solution.non_stochastic_steady_state = get_non_stochastic_steady_state_internal(ùìÇ)
                ùìÇ.solution.NSSS_outdated = false
        end
        if length(ùìÇ.solution.perturbation.first_order.solution_matrix) == 0 && algorithm ‚àà [:dynare, :riccati, :first_order]
                jacobian = calculate_jacobian(ùìÇ.parameter_values,ùìÇ)

                sol_mat = calculate_first_order_solution(jacobian; T = ùìÇ.timings)

                state_update = function(state::Vector{Float64}, shock::Vector{Float64}) sol_mat * [state[ùìÇ.timings.past_not_future_and_mixed_idx]; shock] end
                
                ùìÇ.solution.perturbation.first_order = perturbation_solution(sol_mat, state_update)
                
                ùìÇ.solution.non_stochastic_steady_state = get_non_stochastic_steady_state_internal(ùìÇ)
                ùìÇ.solution.NSSS_outdated = false
        end
        if length(ùìÇ.solution.perturbation.second_order.solution_matrix) == 0 && :second_order == algorithm #‚àà ùìÇ.solution.algorithm
                # calculate_second_order_solution!(ùìÇ)
                if length(ùìÇ.solution.perturbation.first_order.solution_matrix) == 0  
                    jacobian = calculate_jacobian(ùìÇ.parameter_values,ùìÇ)   
                                         
                    sol_mat = calculate_first_order_solution(‚àá‚ÇÅ; T = ùìÇ.timings)

                    state_update = function(state::Vector{Float64}, shock::Vector{Float64}) sol_mat * [state[ùìÇ.timings.past_not_future_and_mixed_idx]; shock] end
                            
                    ùìÇ.solution.perturbation.first_order = perturbation_solution(sol_mat, state_update)
                    
                    ùìÇ.solution.non_stochastic_steady_state = get_non_stochastic_steady_state_internal(ùìÇ)
                    ùìÇ.solution.NSSS_outdated = false
                end

                jacobian = calculate_jacobian(ùìÇ.parameter_values,ùìÇ)
                hessian = calculate_hessian(ùìÇ.parameter_values,ùìÇ)

                ùêí‚ÇÇ = calculate_second_order_solution(jacobian, 
                                                        hessian, 
                                                ùìÇ.solution.perturbation.first_order.solution_matrix; 
                                                T = ùìÇ.timings)

                ùêí‚ÇÅ = [ùìÇ.solution.perturbation.first_order.solution_matrix[:,1:ùìÇ.timings.nPast_not_future_and_mixed] zeros(ùìÇ.timings.nVars) ùìÇ.solution.perturbation.first_order.solution_matrix[:,ùìÇ.timings.nPast_not_future_and_mixed+1:end]]
                
                ùìÇ.solution.perturbation.second_order.solution_matrix = ùêí‚ÇÇ
                ùìÇ.solution.perturbation.second_order.state_update = function(state::Vector{Float64}, shock::Vector{Float64})
                    aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx]
                                1
                                shock]
                    return ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2
                end


                state = zeros(ùìÇ.timings.nVars)
                shock = zeros(ùìÇ.timings.nExo)

                delta = 1

                while delta > eps(Float64)
                    aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx,:]
                                1
                                shock]
                    state_tmp =  ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2
                    delta = sum(abs,state_tmp - state)
                    state = state_tmp
                end
                non_stochastic_steady_state = ùìÇ.solution.non_stochastic_steady_state[1:length(ùìÇ.var)]
                ùìÇ.solution.perturbation.second_order.stochastic_steady_state = non_stochastic_steady_state + vec(state)
                ùìÇ.solution.outdated = false

        end
        if length(ùìÇ.solution.perturbation.third_order.solution_matrix) == 0 && :third_order == algorithm #‚àà ùìÇ.solution.algorithm
                # calculate_third_order_solution(ùìÇ)

                # make sure 1st order solution is available
                if length(ùìÇ.solution.perturbation.first_order.solution_matrix) == 0
                    jacobian = calculate_jacobian(ùìÇ.parameter_values,ùìÇ)

                    sol_mat = calculate_first_order_solution(jacobian; T = ùìÇ.timings)
                    
                    state_update = function(state::Vector{Float64}, shock::Vector{Float64}) sol_mat * [state[ùìÇ.timings.past_not_future_and_mixed_idx]; shock] end
                    
                    ùìÇ.solution.perturbation.first_order = perturbation_solution(sol_mat, state_update)

                    ùìÇ.solution.outdated = false
                    
                    ùìÇ.solution.non_stochastic_steady_state = get_non_stochastic_steady_state_internal(ùìÇ)
                    ùìÇ.solution.NSSS_outdated = false
                end

                # make sure 2nd order solution is available
                if length(ùìÇ.solution.perturbation.second_order.solution_matrix) == 0
                    # calculate_second_order_solution(ùìÇ)
                    
                    jacobian = calculate_jacobian(ùìÇ.parameter_values,ùìÇ)
                    hessian = calculate_hessian(ùìÇ.parameter_values,ùìÇ)

                    ùêí‚ÇÇ = calculate_second_order_solution(jacobian, 
                                                        hessian, 
                                                        ùìÇ.solution.perturbation.first_order.solution_matrix; 
                                                        T = ùìÇ.timings)

                    ùêí‚ÇÅ = [ùìÇ.solution.perturbation.first_order.solution_matrix[:,1:ùìÇ.timings.nPast_not_future_and_mixed] zeros(ùìÇ.timings.nVars) ùìÇ.solution.perturbation.first_order.solution_matrix[:,ùìÇ.timings.nPast_not_future_and_mixed+1:end]]
                    
                    ùìÇ.solution.perturbation.second_order.solution_matrix = ùêí‚ÇÇ
                    ùìÇ.solution.perturbation.second_order.state_update = function(state::Vector{Float64}, shock::Vector{Float64})
                        aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx]
                                    1
                                    shock]
                        return ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2
                    end


                    state = zeros(ùìÇ.timings.nVars)
                    shock = zeros(ùìÇ.timings.nExo)

                    delta = 1

                    while delta > eps(Float64)
                        aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx,:]
                                    1
                                    shock]
                        state_tmp =  ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2
                        delta = sum(abs,state_tmp - state)
                        state = state_tmp
                    end
                    non_stochastic_steady_state = ùìÇ.solution.non_stochastic_steady_state[1:length(ùìÇ.var)]
                    ùìÇ.solution.perturbation.second_order.stochastic_steady_state = non_stochastic_steady_state + vec(state)
                    ùìÇ.solution.outdated = false

                end

                jacobian = calculate_jacobian(ùìÇ.parameter_values,ùìÇ)
                hessian = calculate_hessian(ùìÇ.parameter_values,ùìÇ)
                ‚àá‚ÇÉ = calculate_third_order_derivatives(ùìÇ.parameter_values,ùìÇ)

                ùêí‚ÇÉ = calculate_third_order_solution(jacobian, 
                                                        hessian, 
                                                        ‚àá‚ÇÉ, 
                                                        ùìÇ.solution.perturbation.first_order.solution_matrix, 
                                                        ùìÇ.solution.perturbation.second_order.solution_matrix; 
                                                        T = ùìÇ.timings)


                ùêí‚ÇÇ = ùìÇ.solution.perturbation.second_order.solution_matrix
                
                ùêí‚ÇÅ = [ùìÇ.solution.perturbation.first_order.solution_matrix[:,1:ùìÇ.timings.nPast_not_future_and_mixed] zeros(ùìÇ.timings.nVars) ùìÇ.solution.perturbation.first_order.solution_matrix[:,ùìÇ.timings.nPast_not_future_and_mixed+1:end]]
                
                ùìÇ.solution.perturbation.third_order.solution_matrix = ùêí‚ÇÉ
                ùìÇ.solution.perturbation.third_order.state_update = function(state::Vector{Float64}, shock::Vector{Float64})
                    
                    aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx]
                                 1
                                 shock]

                    return ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2 + ùêí‚ÇÉ * ‚Ñí.kron(‚Ñí.kron(aug_state,aug_state),aug_state) / 6
                end

                state = zeros(ùìÇ.timings.nVars)
                shock = zeros(ùìÇ.timings.nExo)

                delta = 1

                while delta > eps(Float64)
                    aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx,:]
                                 1
                                 shock]

                    state_tmp =  ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2 + ùêí‚ÇÉ * ‚Ñí.kron(‚Ñí.kron(aug_state,aug_state),aug_state) / 6
                    delta = sum(abs,state_tmp - state)
                    state = state_tmp
                end
                non_stochastic_steady_state = ùìÇ.solution.non_stochastic_steady_state[1:length(ùìÇ.var)]
                ùìÇ.solution.perturbation.third_order.stochastic_steady_state = non_stochastic_steady_state + vec(state)
                ùìÇ.solution.outdated = false
        end
    end
end





function write_functions_mapping!(ùìÇ::‚Ñ≥)
    present_varss = map(x->Symbol(string(x) * "‚Çç‚ÇÄ‚Çé"),sort(union(ùìÇ.var_present,ùìÇ.aux_present,ùìÇ.exo_present)))
    shock_varss   = map(x->Symbol(string(x) * "‚Çç‚Çì‚Çé"),ùìÇ.exo)
    future_varss  = map(x->Symbol(string(x) * "‚Çç‚ÇÅ‚Çé"),sort(union(ùìÇ.var_future,ùìÇ.aux_future,ùìÇ.exo_future)))
    past_varss    = map(x->Symbol(string(x) * "‚Çç‚Çã‚ÇÅ‚Çé"),sort(union(ùìÇ.var_past,ùìÇ.aux_past,ùìÇ.exo_past)))
    ss_varss      = map(x->Symbol(string(x) * "‚Çç‚Çõ‚Çõ‚Çé"),ùìÇ.var)

    steady_state = []
    for ii in 1:length(ùìÇ.var)
        push!(steady_state,:($(ss_varss[ii]) = XÃÑ[$ii]))
        # ii += 1
    end

    ii = 1

    alll = []
    for j in 1:length(future_varss)
        push!(alll,:($(future_varss[j]) = X[$ii]))
        ii += 1
    end

    for i in 1:length(present_varss)
        push!(alll,:($(present_varss[i]) = X[$ii]))
        ii += 1
    end

    for l in 1:length(past_varss)
        push!(alll,:($(past_varss[l]) = X[$ii]))
        ii += 1
    end

    for k in 1:length(shock_varss)
        push!(alll,:($(shock_varss[k]) = X[$ii]))
        ii += 1
    end


    paras = []
    push!(paras,:((;$(ùìÇ.par...)) = params))

    # watch out with naming of parameters in model and functions
    mod_func2 = :(function model_function_uni_redux(X::Vector{Real}, params::Vector{Real}, XÃÑ::Vector{Real})
        $(alll...)
        $(paras...)
        $(steady_state...)
        [$(ùìÇ.dyn_equations...)]
    end)


    ùìÇ.model_function = @RuntimeGeneratedFunction(mod_func2)
    # model_function = ùìÇ.model_function

    calib_eqs = []
    for i in 1:length(ùìÇ.solved_vals) 
        eqs   = ùìÇ.solved_vals[i]
        varss = ùìÇ.solved_vars[i]
        push!(calib_eqs,:($varss = $eqs))
    end

    for i in 1:length(ùìÇ.exo)
        varss = ùìÇ.exo[i]
        push!(calib_eqs,:($varss = 0))
    end

    calib_pars = []
    for i in 1:length(ùìÇ.parameters)
        parss = ùìÇ.parameters[i]
        push!(calib_pars,:($parss = parameters[$i]))
    end

    var_out = []
    ii =  1
    for i in 1:length(ùìÇ.var) 
        push!(var_out,:($(ùìÇ.var[i]) = SS[$ii]))
        ii += 1
    end

    par_out = []
    for i in 1:length(ùìÇ.calibration_equations_parameters) 
        push!(par_out,:($(ùìÇ.calibration_equations_parameters[i]) = SS[$ii]))
        ii += 1
    end

    calib_pars = []
    for i in 1:length(ùìÇ.parameters)
        parss = ùìÇ.parameters[i]
        push!(calib_pars,:($parss = parameters[$i]))
    end

    test_func = :(function test_SS(parameters::Vector{Float64}, SS::Vector{Float64})
        $(calib_pars...) 
        # var, par = get_non_stochastic_steady_state(ùìÇ)
        $(var_out...)
        $(par_out...)
        [$(ùìÇ.ss_equations...),$(ùìÇ.calibration_equations...)]
        # all(isapprox.([$(ùìÇ.ss_equations...)],0,atol = eps(Float32)))
    end)
    # println(test_func)

    ùìÇ.solution.valid_steady_state_solution = @RuntimeGeneratedFunction(test_func)

    
    ùìÇ.timings = sort_and_index_symbols( ùìÇ.var,
                                        ùìÇ.var_past,
                                        ùìÇ.var_future,
                                        ùìÇ.aux,
                                        ùìÇ.aux_past,
                                        ùìÇ.aux_future,
                                        ùìÇ.exo,
                                        ùìÇ.exo_past,
                                        ùìÇ.exo_present,
                                        ùìÇ.exo_future)
    
    ùìÇ.solution.outdated = true
    return nothing
end






# function sort_and_index_symbols!(ùìÇ::‚Ñ≥)
function sort_and_index_symbols(var::Vector{Symbol},
                                var_past::Vector{Symbol},
                                var_future::Vector{Symbol},
                                aux::Vector{Symbol},
                                aux_past::Vector{Symbol},
                                aux_future::Vector{Symbol},
                                exo::Vector{Symbol},
                                exo_past::Vector{Symbol},
                                exo_present::Vector{Symbol},
                                exo_future::Vector{Symbol})

    var = sort(union(var, aux, exo_past, exo_future))
    var_past = sort(union(var_past, aux_past, exo_past))
    var_future = sort(union(var_future, aux_future, exo_future))

    present_only              = sort(setdiff(var,union(var_past,var_future)))
    future_not_past           = sort(setdiff(var_future, var_past))
    past_not_future           = sort(setdiff(var_past, var_future))
    mixed                     = sort(setdiff(var, union(present_only, future_not_past, past_not_future)))
    future_not_past_and_mixed = sort(union(future_not_past,mixed))
    past_not_future_and_mixed = sort(union(past_not_future,mixed))
    present_but_not_only      = sort(setdiff(var,present_only))
    mixed_in_past             = sort(intersect(var_past, mixed))
    not_mixed_in_past         = sort(setdiff(var_past,mixed_in_past))
    mixed_in_future           = sort(intersect(var_future, mixed))
    exo                       = sort(exo)
    var                       = sort(var)
    aux                       = sort(aux)
    exo_present               = sort(exo_present)

    nPresent_only              = length(present_only)
    nMixed                     = length(mixed)
    nFuture_not_past_and_mixed = length(future_not_past_and_mixed)
    nPast_not_future_and_mixed = length(past_not_future_and_mixed)
    nPresent_but_not_only      = length(present_but_not_only)
    nVars                      = length(var)
    nExo                       = length(exo)

    present_only_idx              = indexin(present_only,var)
    present_but_not_only_idx      = indexin(present_but_not_only,var)
    future_not_past_and_mixed_idx = indexin(future_not_past_and_mixed,var)
    past_not_future_and_mixed_idx = indexin(past_not_future_and_mixed,var)
    mixed_in_future_idx           = indexin(mixed_in_future,var_future)
    mixed_in_past_idx             = indexin(mixed_in_past,var_past)
    not_mixed_in_past_idx         = indexin(not_mixed_in_past,var_past)
    past_not_future_idx           = indexin(past_not_future,var)

    reorder       = map(x->(getindex(1:nVars, x .== [present_only..., past_not_future..., future_not_past_and_mixed...]))[1], var)
    dynamic_order = map(x->(getindex(1:nPresent_but_not_only, x .== [past_not_future..., future_not_past_and_mixed...]))[1], present_but_not_only)

    return timings(present_only,
                    future_not_past,
                    past_not_future,
                    mixed,
                    future_not_past_and_mixed,
                    past_not_future_and_mixed,
                    present_but_not_only,
                    mixed_in_past,
                    not_mixed_in_past,
                    mixed_in_future,
                    exo,
                    var,
                    aux,
                    exo_present,

                    nPresent_only,
                    nMixed,
                    nFuture_not_past_and_mixed,
                    nPast_not_future_and_mixed,
                    nPresent_but_not_only,
                    nVars,
                    nExo,

                    present_only_idx,
                    present_but_not_only_idx,
                    future_not_past_and_mixed_idx,
                    not_mixed_in_past_idx,
                    past_not_future_and_mixed_idx,
                    mixed_in_past_idx,
                    mixed_in_future_idx,
                    past_not_future_idx,

                    reorder,
                    dynamic_order)
end




write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Pair{Symbol,<: Number}) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict(parameters))
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Tuple{Pair{Symbol,<: Number},Vararg{Pair{Symbol,<: Number}}}) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict(parameters))



function write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Dict{Symbol,<: Number})
    if length(setdiff(collect(keys(parameters)),ùìÇ.parameters))>0
        println("Parameters not part of the model: ",setdiff(collect(keys(parameters)),ùìÇ.parameters))
        for kk in setdiff(collect(keys(parameters)),ùìÇ.parameters)
            delete!(parameters,kk)
        end
    end

    bounds_broken = false

    for i in 1:length(parameters)
        bnd_idx = findfirst(x->x==collect(keys(parameters))[i],ùìÇ.bounded_vars)
        if !isnothing(bnd_idx)
            if collect(values(parameters))[i] > ùìÇ.upper_bounds[bnd_idx]
                # println("Calibration is out of bounds for ",collect(keys(parameters))[i],":\t",collect(values(parameters))[i]," > ",ùìÇ.upper_bounds[bnd_idx] + eps())
                println("Bounds error for",collect(keys(parameters))[i]," < ",ùìÇ.upper_bounds[bnd_idx] + eps(),"\tparameter value: ",collect(values(parameters))[i])
                bounds_broken = true
                continue
            end
            if collect(values(parameters))[i] < ùìÇ.lower_bounds[bnd_idx]
                # println("Calibration is out of bounds for ",collect(keys(parameters))[i],":\t",collect(values(parameters))[i]," < ",ùìÇ.lower_bounds[bnd_idx] - eps())
                println("Bounds error for",collect(keys(parameters))[i]," > ",ùìÇ.lower_bounds[bnd_idx] + eps(),"\tparameter value: ",collect(values(parameters))[i])
                bounds_broken = true
                continue
            end
        end
    end

    if bounds_broken
        println("Parameters unchanged.")
    else
        ntrsct_idx = map(x-> getindex(1:length(ùìÇ.parameter_values),ùìÇ.parameters .== x)[1],collect(keys(parameters)))
        

        
        if !all(ùìÇ.parameter_values[ntrsct_idx] .== collect(values(parameters)))
            println("Parameter changes: ")
            ùìÇ.solution.outdated = true
        end
            
        for i in 1:length(parameters)
            if ùìÇ.parameter_values[ntrsct_idx[i]] != collect(values(parameters))[i]
                if collect(keys(parameters))[i] ‚àà ùìÇ.SS_dependencies[end][2] && ùìÇ.solution.NSSS_outdated == false
                    ùìÇ.solution.NSSS_outdated = true
                    # println("SS outdated.")
                end
                
                println("\t",ùìÇ.parameters[ntrsct_idx[i]],"\tfrom ",ùìÇ.parameter_values[ntrsct_idx[i]],"\tto ",collect(values(parameters))[i])

                ùìÇ.parameter_values[ntrsct_idx[i]] = collect(values(parameters))[i]
            end
        end
    end

    if ùìÇ.solution.NSSS_outdated == true println("New parameters changed the steady state.") end
end


write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Tuple{<: Number,Vararg{<: Number}}) = write_parameters_input!(ùìÇ::‚Ñ≥, vec(collect(parameters)))
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Matrix{<: Number}) = write_parameters_input!(ùìÇ::‚Ñ≥, vec(collect(parameters)))


function write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Vector{<: Number})
    if length(parameters) > length(ùìÇ.parameter_values)
        println("Model has "*string(length(ùìÇ.parameter_values))*" parameters. "*string(length(parameters))*" were provided. The following will be ignored: "*string(parameters[length(ùìÇ.parameter_values)+1:end]...))

        parameters = parameters[1:length(ùìÇ.parameter_values)]
    end

    bounds_broken = false

    for i in 1:length(parameters)
        bnd_idx = findfirst(x -> x == ùìÇ.parameters[i], ùìÇ.bounded_vars)
        if !isnothing(bnd_idx)
            if collect(values(parameters))[i] > ùìÇ.upper_bounds[bnd_idx]
                println("Bounds error for",ùìÇ.parameters[i]," < ",ùìÇ.upper_bounds[bnd_idx] + eps(),"\tparameter value: ",ùìÇ.parameter_values[i])
                bounds_broken = true
                continue
            end
            if collect(values(parameters))[i] < ùìÇ.lower_bounds[bnd_idx]
                println("Bounds error for",ùìÇ.parameters[i]," > ",ùìÇ.lower_bounds[bnd_idx] + eps(),"\tparameter value: ",ùìÇ.parameter_values[i])
                bounds_broken = true
                continue
            end
        end
    end

    if bounds_broken
        println("Parameters unchanged.")
    else
        if !all(parameters .== ùìÇ.parameter_values[1:length(parameters)])
            ùìÇ.solution.outdated = true

            match_idx = parameters .!= ùìÇ.parameter_values[1:length(parameters)]

            changed_vals = parameters[match_idx]
            changes_pars = ùìÇ.parameters[1:length(parameters)][match_idx]

            for p in changes_pars
                if p ‚àà ùìÇ.SS_dependencies[end][2] && ùìÇ.solution.NSSS_outdated == false
                    ùìÇ.solution.NSSS_outdated = true
                    # println("SS outdated.")
                end
            end

            println("Parameter changes: ")
            for ii in 1:sum(match_idx)
                println("\t",changes_pars[ii],"\tfrom ",ùìÇ.parameter_values[1:length(parameters)][match_idx][ii],"\tto ",changed_vals[ii])
            end

            ùìÇ.parameter_values[1:length(parameters)][match_idx] = parameters[match_idx]
        end
    end
    if ùìÇ.solution.NSSS_outdated == true println("New parameters changed the steady state.") end
end



function SS_parameter_derivatives(parameters::Vector{<: Number}, parameters_idx, ùìÇ::‚Ñ≥)
    ùìÇ.parameter_values[parameters_idx] = parameters
    ùìÇ.SS_solve_func(ùìÇ.parameter_values, ùìÇ.SS_init_guess, ùìÇ)
end


function SS_parameter_derivatives(parameters::Number, parameters_idx::Int, ùìÇ::‚Ñ≥)
    ùìÇ.parameter_values[parameters_idx] = parameters
    ùìÇ.SS_solve_func(ùìÇ.parameter_values, ùìÇ.SS_init_guess, ùìÇ)
end


function covariance_parameter_derivatives(parameters::Vector{<: Number}, parameters_idx, ùìÇ::‚Ñ≥)
    ùìÇ.parameter_values[parameters_idx] = parameters
    convert(Vector{Number},max.(‚Ñí.diag(calculate_covariance(ùìÇ.parameter_values, ùìÇ)),eps(Float64)))
end


function covariance_parameter_derivatives(parameters::Number, parameters_idx::Int, ùìÇ::‚Ñ≥)
    ùìÇ.parameter_values[parameters_idx] = parameters
    convert(Vector{Number},max.(‚Ñí.diag(calculate_covariance(ùìÇ.parameter_values, ùìÇ)),eps(Float64)))
end



function get_non_stochastic_steady_state_internal(ùìÇ::‚Ñ≥; parameters = nothing)

    solve!(ùìÇ;dynamics = false,parameters = parameters)

    return ùìÇ.solution.NSSS_outdated ? ùìÇ.SS_solve_func(ùìÇ.parameter_values, ùìÇ.SS_init_guess, ùìÇ) : ùìÇ.solution.non_stochastic_steady_state
end



function calculate_jacobian(parameters::Vector{<: Number}, ùìÇ::‚Ñ≥)
    SS_and_pars = ùìÇ.SS_solve_func(parameters, ùìÇ.SS_init_guess, ùìÇ)
    non_stochastic_steady_state = SS_and_pars[1:end - length(ùìÇ.calibration_equations)]
    calibrated_parameters = SS_and_pars[(end - length(ùìÇ.calibration_equations)+1):end]

    par = ComponentVector( vcat(parameters,calibrated_parameters),Axis(vcat(ùìÇ.parameters,ùìÇ.calibration_equations_parameters)))
    SS = ComponentVector(non_stochastic_steady_state, Axis(sort(union(ùìÇ.exo_present,ùìÇ.var))))

    SS_past =       SS[[indexin(sort([ùìÇ.var_past; map(x -> Symbol(replace(string(x), r"·¥∏‚ÅΩ‚Åª[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ|·¥∏‚ÅΩ[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")),  union(ùìÇ.aux_past,ùìÇ.exo_past))]), sort(union(ùìÇ.var,ùìÇ.exo_present)))...]]#; zeros(length(ùìÇ.exo_past))...]
    SS_present =    SS[[indexin(sort([ùìÇ.var_present; map(x -> Symbol(replace(string(x), r"·¥∏‚ÅΩ‚Åª[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ|·¥∏‚ÅΩ[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")),  union(ùìÇ.aux_present,ùìÇ.exo_present))]), sort(union(ùìÇ.var,ùìÇ.exo_present)))...]]#; zeros(length(ùìÇ.exo_present))...]
    SS_future =     SS[[indexin(sort([ùìÇ.var_future; map(x -> Symbol(replace(string(x), r"·¥∏‚ÅΩ‚Åª[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ|·¥∏‚ÅΩ[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")),  union(ùìÇ.aux_future,ùìÇ.exo_future))]), sort(union(ùìÇ.var,ùìÇ.exo_present)))...]]#; zeros(length(ùìÇ.exo_future))...]

    shocks_ss = zeros(length(ùìÇ.exo))

    return ‚Ñ±.jacobian(x -> ùìÇ.model_function(x, par, SS), [SS_future; SS_present; SS_past; shocks_ss])
end



function calculate_hessian(parameters::Vector{<: Number}, ùìÇ::‚Ñ≥)
    SS_and_pars = ùìÇ.SS_solve_func(parameters, ùìÇ.SS_init_guess, ùìÇ)
    non_stochastic_steady_state = SS_and_pars[1:length(ùìÇ.var)]
    calibrated_parameters = SS_and_pars[length(ùìÇ.var)+1:end]

    par = ComponentVector( vcat(parameters,calibrated_parameters),Axis(vcat(ùìÇ.parameters,ùìÇ.calibration_equations_parameters)))
    SS = ComponentVector(non_stochastic_steady_state, Axis(ùìÇ.var))

    SS_past =       SS[[indexin(sort([ùìÇ.var_past; map(x -> Symbol(replace(string(x), r"·¥∏‚ÅΩ‚Åª[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ|·¥∏‚ÅΩ[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")),  union(ùìÇ.aux_past,ùìÇ.exo_past))]), sort(union(ùìÇ.var,ùìÇ.exo_present)))...]]#; zeros(length(ùìÇ.exo_past))...]
    SS_present =    SS[[indexin(sort([ùìÇ.var_present; map(x -> Symbol(replace(string(x), r"·¥∏‚ÅΩ‚Åª[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ|·¥∏‚ÅΩ[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")),  union(ùìÇ.aux_present,ùìÇ.exo_present))]), sort(union(ùìÇ.var,ùìÇ.exo_present)))...]]#; zeros(length(ùìÇ.exo_present))...]
    SS_future =     SS[[indexin(sort([ùìÇ.var_future; map(x -> Symbol(replace(string(x), r"·¥∏‚ÅΩ‚Åª[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ|·¥∏‚ÅΩ[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")),  union(ùìÇ.aux_future,ùìÇ.exo_future))]), sort(union(ùìÇ.var,ùìÇ.exo_present)))...]]#; zeros(length(ùìÇ.exo_future))...]

    shocks_ss = zeros(length(ùìÇ.exo))

    nk = ùìÇ.timings.nPast_not_future_and_mixed + ùìÇ.timings.nVars + ùìÇ.timings.nFuture_not_past_and_mixed + length(ùìÇ.exo)
        
    return sparse(reshape(‚Ñ±.jacobian(x -> ‚Ñ±.jacobian(x -> (ùìÇ.model_function(x, par, SS)), x), [SS_future; SS_present; SS_past; shocks_ss] ), ùìÇ.timings.nVars, nk^2))
end



function calculate_third_order_derivatives(parameters::Vector{<: Number}, ùìÇ::‚Ñ≥)
    SS_and_pars = ùìÇ.SS_solve_func(parameters, ùìÇ.SS_init_guess, ùìÇ)
    non_stochastic_steady_state = SS_and_pars[1:length(ùìÇ.var)]
    calibrated_parameters = SS_and_pars[length(ùìÇ.var)+1:end]

    par = ComponentVector( vcat(parameters,calibrated_parameters),Axis(vcat(ùìÇ.parameters,ùìÇ.calibration_equations_parameters)))
    SS = ComponentVector(non_stochastic_steady_state, Axis(ùìÇ.var))

    SS_past =       SS[[indexin(sort([ùìÇ.var_past; map(x -> Symbol(replace(string(x), r"·¥∏‚ÅΩ‚Åª[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ|·¥∏‚ÅΩ[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")),  union(ùìÇ.aux_past,ùìÇ.exo_past))]), sort(union(ùìÇ.var,ùìÇ.exo_present)))...]]#; zeros(length(ùìÇ.exo_past))...]
    SS_present =    SS[[indexin(sort([ùìÇ.var_present; map(x -> Symbol(replace(string(x), r"·¥∏‚ÅΩ‚Åª[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ|·¥∏‚ÅΩ[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")),  union(ùìÇ.aux_present,ùìÇ.exo_present))]), sort(union(ùìÇ.var,ùìÇ.exo_present)))...]]#; zeros(length(ùìÇ.exo_present))...]
    SS_future =     SS[[indexin(sort([ùìÇ.var_future; map(x -> Symbol(replace(string(x), r"·¥∏‚ÅΩ‚Åª[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ|·¥∏‚ÅΩ[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")),  union(ùìÇ.aux_future,ùìÇ.exo_future))]), sort(union(ùìÇ.var,ùìÇ.exo_present)))...]]#; zeros(length(ùìÇ.exo_future))...]

    shocks_ss = zeros(length(ùìÇ.exo))

    nk = ùìÇ.timings.nPast_not_future_and_mixed + ùìÇ.timings.nVars + ùìÇ.timings.nFuture_not_past_and_mixed + length(ùìÇ.exo)
      
    return sparse(reshape(‚Ñ±.jacobian(x -> ‚Ñ±.jacobian(x -> ‚Ñ±.jacobian(x -> ùìÇ.model_function(x, par, SS), x), x), [SS_future; SS_present; SS_past; shocks_ss] ), ùìÇ.timings.nVars, nk^3))
 end



# function calculate_linear_time_iteration_solution(ùìÇ::‚Ñ≥)
function calculate_linear_time_iteration_solution(jacobian::AbstractMatrix{Float64}; T::timings)
    expand = [‚Ñí.diagm(ones(T.nVars))[T.future_not_past_and_mixed_idx,:],
              ‚Ñí.diagm(ones(T.nVars))[T.past_not_future_and_mixed_idx,:]] 

    ‚àá‚Çä = jacobian[:,1:T.nFuture_not_past_and_mixed] * expand[1]
    ‚àá‚ÇÄ = jacobian[:,T.nFuture_not_past_and_mixed .+ range(1,T.nVars)]
    ‚àá‚Çã = jacobian[:,T.nFuture_not_past_and_mixed + T.nVars .+ range(1,T.nPast_not_future_and_mixed)] * expand[2]
    ‚àá‚Çë = jacobian[:,(T.nFuture_not_past_and_mixed + T.nVars + T.nPast_not_future_and_mixed + 1):end]
  
    maxiter = 1000
    tol = eps(Float32)

    # @btime begin
    F = zero(‚àá‚Çã)
    S = zero(‚àá‚Çã)
    # F = randn(size(‚àá‚Çã))
    # S = randn(size(‚àá‚Çã))
    
    error = one(tol) + tol
    iter = 0

    while error > tol && iter <= maxiter
        FÃÇ = -(‚àá‚Çä * F + ‚àá‚ÇÄ) \ ‚àá‚Çã
        SÃÇ = -(‚àá‚Çã * S + ‚àá‚ÇÄ) \ ‚àá‚Çä
        
        error = maximum(‚àá‚Çä * FÃÇ * FÃÇ + ‚àá‚ÇÄ * FÃÇ + ‚àá‚Çã)
        
        F = FÃÇ
        S = SÃÇ
        
        iter += 1
    end

    if iter == maxiter
        outmessage = "Convergence Failed. Max Iterations Reached. Error: $error"
    elseif maximum(abs,‚Ñí.eigen(F).values) > 1.0
        outmessage = "No Stable Solution Exists!"
    elseif maximum(abs,‚Ñí.eigen(S).values) > 1.0
        outmessage = "Multiple Solutions Exist!"
    # else
    #     outmessage = "Convergence Successful!"
    end

    Q = -(‚àá‚Çä * F + ‚àá‚ÇÄ) \ ‚àá‚Çë
    # F = sparse(F)

    sol_mat = hcat(F[:,T.past_not_future_and_mixed_idx],Q)
    
    return sol_mat
end



function riccati_forward(jacobian::AbstractMatrix{<: Number}; T::timings, explosive::Bool = false)#::AbstractMatrix{Real}
    ‚àá‚Çä = @view jacobian[:,1:T.nFuture_not_past_and_mixed]
    ‚àá‚ÇÄ = @view jacobian[:,T.nFuture_not_past_and_mixed .+ range(1, T.nVars)]
    ‚àá‚Çã = @view jacobian[:,T.nFuture_not_past_and_mixed + T.nVars .+ range(1, T.nPast_not_future_and_mixed)]

    Q    = ‚Ñí.qr(collect(‚àá‚ÇÄ[:,T.present_only_idx]))
    Qinv = Q.Q'

    A‚Çä = Qinv * ‚àá‚Çä
    A‚ÇÄ = Qinv * ‚àá‚ÇÄ
    A‚Çã = Qinv * ‚àá‚Çã

    dynIndex = T.nPresent_only+1:T.nVars

    AÃÉ‚Çä  = @view A‚Çä[dynIndex,:]
    AÃÉ‚Çã  = @view A‚Çã[dynIndex,:]
    AÃÉ‚ÇÄ‚Çä = @view A‚ÇÄ[dynIndex, T.future_not_past_and_mixed_idx]
    AÃÉ‚ÇÄ‚Çã = A‚ÇÄ[dynIndex, T.past_not_future_idx]* ‚Ñí.diagm(ones(T.nPast_not_future_and_mixed))[T.not_mixed_in_past_idx,:]
    
    Z‚Çä = zeros(T.nMixed,T.nFuture_not_past_and_mixed)
    I‚Çä = ‚Ñí.diagm(ones(T.nFuture_not_past_and_mixed))[T.mixed_in_future_idx,:]

    Z‚Çã = zeros(T.nMixed,T.nPast_not_future_and_mixed)
    I‚Çã = ‚Ñí.diagm(ones(T.nPast_not_future_and_mixed))[T.mixed_in_past_idx,:]

    D = vcat(hcat(AÃÉ‚ÇÄ‚Çã, AÃÉ‚Çä), hcat(I‚Çã, Z‚Çä))
    E = vcat(hcat(-AÃÉ‚Çã,-AÃÉ‚ÇÄ‚Çä), hcat(Z‚Çã, I‚Çä))
    # this is the companion form and by itself the linearisation of the matrix polynomial used in the linear time iteration method. see: https://opus4.kobv.de/opus4-matheon/files/209/240.pdf
    schdcmp = ‚Ñí.schur(D,E)

    if explosive # returns false for NaN gen. eigenvalue which is correct here bc they are > 1
        eigenselect = abs.(schdcmp.Œ≤ ./ schdcmp.Œ±) .>= 1

        ‚Ñí.ordschur!(schdcmp, eigenselect)

        Z‚ÇÇ‚ÇÅ = @view schdcmp.Z[T.nPast_not_future_and_mixed+1:end, 1:T.nPast_not_future_and_mixed]
        Z‚ÇÅ‚ÇÅ = @view schdcmp.Z[1:T.nPast_not_future_and_mixed, 1:T.nPast_not_future_and_mixed]

        S‚ÇÅ‚ÇÅ    = @view schdcmp.S[1:T.nPast_not_future_and_mixed, 1:T.nPast_not_future_and_mixed]
        T‚ÇÅ‚ÇÅ    = @view schdcmp.T[1:T.nPast_not_future_and_mixed, 1:T.nPast_not_future_and_mixed]

        Z‚ÇÅ‚ÇÅinv = ‚Ñí.pinv(Z‚ÇÅ‚ÇÅ)
    else
        eigenselect = abs.(schdcmp.Œ≤ ./ schdcmp.Œ±) .< 1

        ‚Ñí.ordschur!(schdcmp, eigenselect)

        Z‚ÇÇ‚ÇÅ = @view schdcmp.Z[T.nPast_not_future_and_mixed+1:end, 1:T.nPast_not_future_and_mixed]
        Z‚ÇÅ‚ÇÅ = @view schdcmp.Z[1:T.nPast_not_future_and_mixed, 1:T.nPast_not_future_and_mixed]

        S‚ÇÅ‚ÇÅ    = @view schdcmp.S[1:T.nPast_not_future_and_mixed, 1:T.nPast_not_future_and_mixed]
        T‚ÇÅ‚ÇÅ    = @view schdcmp.T[1:T.nPast_not_future_and_mixed, 1:T.nPast_not_future_and_mixed]

        Z‚ÇÅ‚ÇÅinv = inv(Z‚ÇÅ‚ÇÅ)
    end
    
    D      = Z‚ÇÇ‚ÇÅ * Z‚ÇÅ‚ÇÅinv
    L      = Z‚ÇÅ‚ÇÅ * (S‚ÇÅ‚ÇÅ \ T‚ÇÅ‚ÇÅ) * Z‚ÇÅ‚ÇÅinv

    sol = vcat(L[T.not_mixed_in_past_idx,:], D)

    AÃÑ‚ÇÄ·µ§  = @view A‚ÇÄ[1:T.nPresent_only, T.present_only_idx]
    A‚Çä·µ§  = @view A‚Çä[1:T.nPresent_only,:]
    AÃÉ‚ÇÄ·µ§  = @view A‚ÇÄ[1:T.nPresent_only, T.present_but_not_only_idx]
    A‚Çã·µ§  = @view A‚Çã[1:T.nPresent_only,:]

    A    = vcat(- AÃÑ‚ÇÄ·µ§ \ (A‚Çä·µ§ * D * L + AÃÉ‚ÇÄ·µ§ * sol[T.dynamic_order,:] + A‚Çã·µ§), sol)
    
    A[T.reorder,:]
end


# function riccati_forward(jacobian::AbstractMatrix{Float64}; T::timings, explosive::Bool = false)
function riccati_conditions(jacc::AbstractMatrix{<: Number}, sol_d::AbstractMatrix{<: Number}; T::timings) #::AbstractMatrix{Real},
    expand = [‚Ñí.diagm(ones(T.nVars))[T.future_not_past_and_mixed_idx,:],
              ‚Ñí.diagm(ones(T.nVars))[T.past_not_future_and_mixed_idx,:]] 

    A = jacc[:,1:T.nFuture_not_past_and_mixed] * expand[1]
    B = jacc[:,T.nFuture_not_past_and_mixed .+ range(1,T.nVars)]
    C = jacc[:,T.nFuture_not_past_and_mixed + T.nVars .+ range(1,T.nPast_not_future_and_mixed)] * expand[2]

    sol_buf = sol_d * expand[2]

    err1 = A * sol_buf * sol_buf + B * sol_buf + C
    return err1[:,T.past_not_future_and_mixed_idx]
end



function riccati_forward(jacc::AbstractMatrix{‚Ñ±.Dual{Z,S,N}}; T::timings = T, explosive::Bool = false) where {Z,S,N}
    # unpack: AoS -> SoA
    jacobian = ‚Ñ±.value.(jacc)
    # you can play with the dimension here, sometimes it makes sense to transpose
    ps = mapreduce(‚Ñ±.partials, hcat, jacc)'

    # get f(vs)
    val = riccati_forward(jacobian;T = T, explosive = explosive)

    # get J(f, vs) * ps (cheating). Write your custom rule here
    B = ‚Ñ±.jacobian(x -> riccati_conditions(x, val; T = T), jacobian)
    A = ‚Ñ±.jacobian(x -> riccati_conditions(jacobian, x; T = T), val)

    jvp = (-A \ B) * ps

    # pack: SoA -> AoS
    return reshape(map(val, eachrow(jvp)) do v, p
        ‚Ñ±.Dual{Z}(v, p...) # Z is the tag
    end,size(val))
end


function calculate_first_order_solution(jacobian::AbstractMatrix{<: Number}; T::timings, explosive::Bool = false)
    A = riccati_forward(jacobian, T = T, explosive = explosive)

    Jm = ‚Ñí.diagm(ones(T.nVars))[T.past_not_future_and_mixed_idx,:]
    
    ‚àá‚Çä = jacobian[:,1:T.nFuture_not_past_and_mixed] * ‚Ñí.diagm(ones(T.nVars))[T.future_not_past_and_mixed_idx,:]
    ‚àá‚ÇÄ = jacobian[:,T.nFuture_not_past_and_mixed .+ range(1,T.nVars)]
    ‚àá‚Çë = jacobian[:,(T.nFuture_not_past_and_mixed + T.nVars + T.nPast_not_future_and_mixed + 1):end]

    B = -((‚àá‚Çä * A * Jm + ‚àá‚ÇÄ) \ ‚àá‚Çë)

    return hcat(A, B)
end



# function calculate_second_order_solution!(ùìÇ::‚Ñ≥)
function  calculate_second_order_solution(‚àá‚ÇÅ::AbstractMatrix{Float64}, #first order derivatives
                                            ‚àá‚ÇÇ::AbstractMatrix{Float64}, #second order derivatives
                                            ùë∫‚ÇÅ::AbstractMatrix{Float64};  #first order solution
                                            T::timings)
    # inspired by Levintal

    tol = eps(Float32)

    # Indices and number of variables
    i‚Çä = T.future_not_past_and_mixed_idx;
    i‚Çã = T.past_not_future_and_mixed_idx;

    n‚Çã = T.nPast_not_future_and_mixed
    n‚Çä = T.nFuture_not_past_and_mixed
    n‚Çë = T.nExo;
    n  = T.nVars
    n‚Çë‚Çã = n‚Çã + 1 + n‚Çë


    # 1st order solution
    ùêí‚ÇÅ = [ùë∫‚ÇÅ[:,1:n‚Çã] zeros(n) ùë∫‚ÇÅ[:,n‚Çã+1:end]] |> sparse
    droptol!(ùêí‚ÇÅ,tol)

    # set up vector to capture volatility effect
    redu = sparsevec(n‚Çë‚Çã - n‚Çë + 1:n‚Çë‚Çã, 1)
    redu_idxs = findnz(‚Ñí.kron(redu, redu))[1]
    ùõî = sparse(redu_idxs[Int.(range(1,n‚Çë^2,n‚Çë))], fill(n‚Çã * (n‚Çë‚Çã + 1) + 1, n‚Çë), 1, n‚Çë‚Çã^2, n‚Çë‚Çã^2)

    ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë = [ùêí‚ÇÅ[i‚Çã,:]; zeros(n‚Çë + 1, n‚Çã) spdiagm(ones(n‚Çë + 1))[1,:] zeros(n‚Çë + 1, n‚Çë)];
    
    ‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã = [(ùêí‚ÇÅ * ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë)[i‚Çä,:]
            ùêí‚ÇÅ
            spdiagm(ones(n‚Çë‚Çã))[[range(1,n‚Çã)...,n‚Çã + 1 .+ range(1,n‚Çë)...],:]];

    ùêí‚ÇÅ‚Çä‚ï±ùüé = [ùêí‚ÇÅ[i‚Çä,:]
            zeros(n‚Çã + n + n‚Çë, n‚Çë‚Çã)];


    # setup compression matrices
    colls2 = [n‚Çë‚Çã * (i-1) + k for i in 1:n‚Çë‚Çã for k in 1:i]
    ùêÇ‚ÇÇ = sparse(colls2, 1:length(colls2) , 1)
    ùêî‚ÇÇ = ùêÇ‚ÇÇ' * sparse([i <= k ? (k - 1) * n‚Çë‚Çã + i : (i - 1) * n‚Çë‚Çã + k for k in 1:n‚Çë‚Çã for i in 1:n‚Çë‚Çã], 1:n‚Çë‚Çã^2, 1)


    ‚àá‚ÇÅ‚Çäùêí‚ÇÅ‚ûï‚àá‚ÇÅ‚ÇÄ = -‚àá‚ÇÅ[:,1:n‚Çä] * ùêí‚ÇÅ[i‚Çä,1:n‚Çã] * ‚Ñí.diagm(ones(n))[i‚Çã,:] - ‚àá‚ÇÅ[:,range(1,n) .+ n‚Çä]

    ‚àá‚ÇÇ‚é∏k‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã‚ûïùõîkùêí‚ÇÅ‚Çä‚ï±ùüé‚éπ = -‚àá‚ÇÇ * (‚Ñí.kron(‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã, ‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã) + ‚Ñí.kron(ùêí‚ÇÅ‚Çä‚ï±ùüé, ùêí‚ÇÅ‚Çä‚ï±ùüé) * ùõî) * ùêÇ‚ÇÇ 

    X = sparse(‚àá‚ÇÅ‚Çäùêí‚ÇÅ‚ûï‚àá‚ÇÅ‚ÇÄ \ ‚àá‚ÇÇ‚é∏k‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã‚ûïùõîkùêí‚ÇÅ‚Çä‚ï±ùüé‚éπ)
    droptol!(X,tol)


    ‚àá‚ÇÅ‚Çä = sparse(‚àá‚ÇÅ[:,1:n‚Çä] * spdiagm(ones(n))[i‚Çä,:])

    B = sparse(‚àá‚ÇÅ‚Çäùêí‚ÇÅ‚ûï‚àá‚ÇÅ‚ÇÄ \ ‚àá‚ÇÅ‚Çä)
    droptol!(B,tol)


    C = (ùêî‚ÇÇ * ‚Ñí.kron(ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë, ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë) + ùêî‚ÇÇ * ùõî) * ùêÇ‚ÇÇ
    droptol!(C,tol)

    A = spdiagm(ones(n))

    lm = LinearMap{Float64}(x -> A * reshape(x,size(X)) - B * reshape(x,size(X)) * C, size(X)[1] * size(X)[2])

    ùêí‚ÇÇ = sparse(reshape(bicgstabl(lm, vec(-X)), size(X))) * ùêî‚ÇÇ # fastest
    droptol!(ùêí‚ÇÇ,tol)

    return ùêí‚ÇÇ
end






# function calculate_third_order_solution!(ùìÇ::‚Ñ≥)
function  calculate_third_order_solution(‚àá‚ÇÅ::AbstractMatrix{Float64}, #first order derivatives
                                            ‚àá‚ÇÇ::AbstractMatrix{Float64}, #second order derivatives
                                            ‚àá‚ÇÉ::AbstractMatrix{Float64}, #third order derivatives
                                            ùë∫‚ÇÅ::AbstractMatrix{Float64}, #first order solution
                                            ùêí‚ÇÇ::AbstractMatrix{Float64}; #second order solution
                                            T::timings)
    # inspired by Levintal

    tol = eps(Float32)

    # Indices and number of variables
    i‚Çä = T.future_not_past_and_mixed_idx;
    i‚Çã = T.past_not_future_and_mixed_idx;

    n‚Çã = T.nPast_not_future_and_mixed
    n‚Çä = T.nFuture_not_past_and_mixed
    n‚Çë = T.nExo;
    n = T.nVars
    nÃÑ = n‚Çã + n + n‚Çä + n‚Çë
    n‚Çë‚Çã = n‚Çã + 1 + n‚Çë


    # 1st order solution
    ùêí‚ÇÅ = [ùë∫‚ÇÅ[:,1:n‚Çã] zeros(n) ùë∫‚ÇÅ[:,n‚Çã+1:end]] |> sparse
    droptol!(ùêí‚ÇÅ,tol)

    # set up vector to capture volatility effect
    redu = sparsevec(n‚Çë‚Çã - n‚Çë + 1:n‚Çë‚Çã, 1)
    redu_idxs = findnz(‚Ñí.kron(redu, redu))[1]
    ùõî = sparse(redu_idxs[Int.(range(1,n‚Çë^2,n‚Çë))], fill(n‚Çã * (n‚Çë‚Çã + 1) + 1, n‚Çë), 1, n‚Çë‚Çã^2, n‚Çë‚Çã^2)


    ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë = [ùêí‚ÇÅ[i‚Çã,:]; zeros(n‚Çë + 1, n‚Çã) spdiagm(ones(n‚Çë + 1))[1,:] zeros(n‚Çë + 1, n‚Çë)];

    ‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã = [(ùêí‚ÇÅ * ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë)[i‚Çä,:]
            ùêí‚ÇÅ
            spdiagm(ones(n‚Çë‚Çã))[[range(1,n‚Çã)...,n‚Çã + 1 .+ range(1,n‚Çë)...],:]];

    ùêí‚ÇÅ‚Çä‚ï±ùüé = [ùêí‚ÇÅ[i‚Çä,:]
            zeros(n‚Çã + n + n‚Çë, n‚Çë‚Çã)];

    ‚àá‚ÇÅ‚Çäùêí‚ÇÅ‚ûï‚àá‚ÇÅ‚ÇÄ = -‚àá‚ÇÅ[:,1:n‚Çä] * ùêí‚ÇÅ[i‚Çä,1:n‚Çã] * ‚Ñí.diagm(ones(n))[i‚Çã,:] - ‚àá‚ÇÅ[:,range(1,n) .+ n‚Çä]


    ‚àá‚ÇÅ‚Çä = sparse(‚àá‚ÇÅ[:,1:n‚Çä] * spdiagm(ones(n))[i‚Çä,:])

    B = sparse(‚àá‚ÇÅ‚Çäùêí‚ÇÅ‚ûï‚àá‚ÇÅ‚ÇÄ \ ‚àá‚ÇÅ‚Çä)
    droptol!(B,tol)
    
    # compression matrices for third order
    colls3 = [n‚Çë‚Çã^2 * (i-1) + n‚Çë‚Çã * (k-1) + l for i in 1:n‚Çë‚Çã for k in 1:i for l in 1:k]
    ùêÇ‚ÇÉ = sparse(colls3, 1:length(colls3) , 1)
    
    idxs = []
    for k in 1:n‚Çë‚Çã
        for j in 1:n‚Çë‚Çã
            for i in 1:n‚Çë‚Çã
                sorted_ids = sort([k,j,i])
                push!(idxs, (sorted_ids[3] - 1) * n‚Çë‚Çã ^ 2 + (sorted_ids[2] - 1) * n‚Çë‚Çã + sorted_ids[1])
            end
        end
    end
    
    ùêî‚ÇÉ = ùêÇ‚ÇÉ' * sparse(idxs,1:n‚Çë‚Çã ^ 3, 1)
    
    
    # permutation matrices
    M = reshape(1:n‚Çë‚Çã^3,1,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã)
    ùêè = sparse(reshape(spdiagm(ones(n‚Çë‚Çã^3))[:,PermutedDimsArray(M,[1, 4, 2, 3])],n‚Çë‚Çã^3,n‚Çë‚Çã^3)
                           + reshape(spdiagm(ones(n‚Çë‚Çã^3))[:,PermutedDimsArray(M,[1, 2, 4, 3])],n‚Çë‚Çã^3,n‚Çë‚Çã^3)
                           + reshape(spdiagm(ones(n‚Çë‚Çã^3))[:,PermutedDimsArray(M,[1, 2, 3, 4])],n‚Çë‚Çã^3,n‚Çë‚Çã^3))
    

    ‚é∏ùêí‚ÇÇkùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚ûïùêí‚ÇÅùêí‚ÇÇ‚Çã‚éπ‚ï±ùêí‚ÇÇ‚ï±ùüé =[(ùêí‚ÇÇ * ‚Ñí.kron(ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë, ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë) + ùêí‚ÇÅ * [ùêí‚ÇÇ[i‚Çã,:] ; zeros(n‚Çë + 1, n‚Çë‚Çã^2)])[i‚Çä,:]
            ùêí‚ÇÇ
            zeros(n‚Çã + n‚Çë, n‚Çë‚Çã^2)];
        
    ùêí‚ÇÇ‚Çä‚ï±ùüé = [ùêí‚ÇÇ[i‚Çä,:] 
             zeros(n‚Çã + n + n‚Çë, n‚Çë‚Çã^2)];
             ùêí‚ÇÅ‚Çä‚ï±ùüé
    
    ùêó‚ÇÉ = -‚àá‚ÇÉ * ‚Ñí.kron(‚Ñí.kron(‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã, ‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã), ‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã)
    
    ùêè‚ÇÅ‚Çó = sparse(spdiagm(ones(nÃÑ^3))[vec(permutedims(reshape(1:nÃÑ^3,nÃÑ,nÃÑ,nÃÑ),(1,3,2))),:])
    ùêè‚ÇÅ·µ£ = sparse(spdiagm(ones(n‚Çë‚Çã^3))[:,vec(permutedims(reshape(1:n‚Çë‚Çã^3,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã),(1,3,2)))])
    ùêè‚ÇÇ‚Çó = sparse(spdiagm(ones(nÃÑ^3))[vec(permutedims(reshape(1:nÃÑ^3,nÃÑ,nÃÑ,nÃÑ),(3,1,2))),:])
    ùêè‚ÇÇ·µ£ = sparse(spdiagm(ones(n‚Çë‚Çã^3))[:,vec(permutedims(reshape(1:n‚Çë‚Çã^3,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã),(3,1,2)))])

    tmpkron = ‚Ñí.kron(‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã, ‚Ñí.kron(ùêí‚ÇÅ‚Çä‚ï±ùüé, ùêí‚ÇÅ‚Çä‚ï±ùüé) * ùõî)
    out = - ‚àá‚ÇÉ * tmpkron - ‚àá‚ÇÉ * ùêè‚ÇÅ‚Çó * tmpkron * ùêè‚ÇÅ·µ£ - ‚àá‚ÇÉ * ùêè‚ÇÇ‚Çó * tmpkron * ùêè‚ÇÇ·µ£
    ùêó‚ÇÉ += out
    
    
    
    tmpùêó‚ÇÉ = -‚àá‚ÇÇ * ‚Ñí.kron(‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã,‚é∏ùêí‚ÇÇkùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚ûïùêí‚ÇÅùêí‚ÇÇ‚Çã‚éπ‚ï±ùêí‚ÇÇ‚ï±ùüé) 
    
    ùêè‚ÇÅ‚Çó = sparse(spdiagm(ones(n‚Çë‚Çã^3))[vec(permutedims(reshape(1:n‚Çë‚Çã^3,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã),(2,1,3))),:])
    ùêè‚ÇÅ·µ£ = sparse(spdiagm(ones(n‚Çë‚Çã^3))[:,vec(permutedims(reshape(1:n‚Çë‚Çã^3,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã),(2,1,3)))])

    tmpkron1 = -‚àá‚ÇÇ *  ‚Ñí.kron(ùêí‚ÇÅ‚Çä‚ï±ùüé,ùêí‚ÇÇ‚Çä‚ï±ùüé)
    tmpkron2 = ‚Ñí.kron(ùõî,ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë)
    out2 = tmpkron1 * tmpkron2 +  tmpkron1 * ùêè‚ÇÅ‚Çó * tmpkron2 * ùêè‚ÇÅ·µ£
    
    ùêó‚ÇÉ += (tmpùêó‚ÇÉ + out2 + -‚àá‚ÇÇ * ‚Ñí.kron(‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã, ùêí‚ÇÇ‚Çä‚ï±ùüé * ùõî)) * ùêè# |> findnz
    
    ùêó‚ÇÉ += -‚àá‚ÇÅ‚Çä * ùêí‚ÇÇ * ‚Ñí.kron(ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë, [ùêí‚ÇÇ[i‚Çã,:] ; zeros(size(ùêí‚ÇÅ)[2] - n‚Çã, n‚Çë‚Çã^2)]) * ùêè
    droptol!(ùêó‚ÇÉ,tol)
    
    
    X = sparse(‚àá‚ÇÅ‚Çäùêí‚ÇÅ‚ûï‚àá‚ÇÅ‚ÇÄ \ ùêó‚ÇÉ * ùêÇ‚ÇÉ)
    droptol!(X,tol)
    
    
    ùêè‚ÇÅ‚Çó = sparse(spdiagm(ones(n‚Çë‚Çã^3))[vec(permutedims(reshape(1:n‚Çë‚Çã^3,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã),(1,3,2))),:])
    ùêè‚ÇÅ·µ£ = sparse(spdiagm(ones(n‚Çë‚Çã^3))[:,vec(permutedims(reshape(1:n‚Çë‚Çã^3,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã),(1,3,2)))])
    ùêè‚ÇÇ‚Çó = sparse(spdiagm(ones(n‚Çë‚Çã^3))[vec(permutedims(reshape(1:n‚Çë‚Çã^3,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã),(3,1,2))),:])
    ùêè‚ÇÇ·µ£ = sparse(spdiagm(ones(n‚Çë‚Çã^3))[:,vec(permutedims(reshape(1:n‚Çë‚Çã^3,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã),(3,1,2)))])

    tmpkron = ‚Ñí.kron(ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë,ùõî)
    
    C = ùêî‚ÇÉ * tmpkron + ùêî‚ÇÉ * ùêè‚ÇÅ‚Çó * tmpkron * ùêè‚ÇÅ·µ£ + ùêî‚ÇÉ * ùêè‚ÇÇ‚Çó * tmpkron * ùêè‚ÇÇ·µ£
    C += ùêî‚ÇÉ * ‚Ñí.kron(ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë,‚Ñí.kron(ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë,ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë))
    C *= ùêÇ‚ÇÉ
    droptol!(C,tol)
    
    
    A = spdiagm(ones(n))
    lm = LinearMap{Float64}(x -> A * reshape(x,size(X)) - B * reshape(x,size(X)) * C, size(X)[1] * size(X)[2])
    
    ùêí‚ÇÉ = sparse(reshape(bicgstabl(lm, vec(-X)),size(X))) * ùêî‚ÇÉ # fastest
    droptol!(ùêí‚ÇÉ,tol)
    
    
    return ùêí‚ÇÉ
end





function irf(state_update::Function, initial_state::Vector{Float64}, T::timings; 
    periods::Int = 40, 
    shocks::Symbol_input = :all, 
    variables::Symbol_input = :all, 
    negative_shock::Bool = false)

    if shocks == :all
        shock_idx = 1:T.nExo
    elseif shocks == :simulate
        shock_idx = 1:T.nExo
    elseif shocks == :none
        shock_idx = 1:T.nExo
    elseif shocks isa Matrix{Symbol}
        if !issubset(shocks,T.exo)
            return @warn "Following shocks are not part of the model: " * string.(setdiff(shocks,T.exo))
        end
        shock_idx = getindex(1:T.nExo,convert(Vector{Bool},vec(sum(shocks .== T.exo,dims= 2))))
    elseif shocks isa Vector{Symbol}
        if !issubset(shocks,ùìÇ.timings.exo)
            return @warn "Following shocks are not part of the model: " * string.(setdiff(shocks,ùìÇ.timings.exo))
        end
        shock_idx = getindex(1:ùìÇ.timings.nExo,convert(Vector{Bool},vec(sum(reshape(shocks,1,length(variables)) .== ùìÇ.timings.exo,dims= 2))))
    elseif shocks isa Tuple
        if !issubset(shocks,ùìÇ.timings.exo)
            return @warn "Following shocks are not part of the model: " * string.(setdiff(shocks,ùìÇ.timings.exo))
        end
        shock_idx = getindex(1:ùìÇ.timings.nExo,convert(Vector{Bool},vec(sum(reshape(collect(shocks),1,length(variables)) .== ùìÇ.timings.exo,dims= 2))))
    elseif shocks isa Symbol
        if !issubset([shocks],T.exo)
            return @warn "Following shock is not part of the model: " * string(setdiff([shocks],T.exo)[1])
        end
        shock_idx = getindex(1:T.nExo,shocks .== T.exo)
    else
        return @warn "Invalid argument in shocks"
    end

    var_idx = parse_variables_input_to_index(variables, T)

    if shocks == :simulate
        ET = randn(T.nExo,periods)

        Y = zeros(T.nVars,periods,1)
        Y[:,1,1] = state_update(initial_state,ET[:,1])

        for t in 1:periods-1
            Y[:,t+1,1] = state_update(Y[:,t,1],ET[:,t+1])
        end

        return KeyedArray(Y[var_idx,:,:];  Variables = T.var[var_idx], Period = 1:periods, Shock = [:simulate])
    elseif shocks == :none
        Y = zeros(T.nVars,periods,1)
        Y[:,1,1] = state_update(initial_state,[0.0])

        for t in 1:periods-1
            Y[:,t+1,1] = state_update(Y[:,t,1],[0.0])
        end

        return KeyedArray(Y[var_idx,:,:];  Variables = T.var[var_idx], Period = 1:periods, Shock = [:none])
    else
        Y = zeros(T.nVars,periods,T.nExo)

        for ii in shock_idx
            if shocks != :simulate
                ET = zeros(T.nExo,periods)
                ET[ii,1] = negative_shock ? -1 : 1
            end

            Y[:,1,ii] = state_update(initial_state,ET[:,1])

            for t in 1:periods-1
                Y[:,t+1,ii] = state_update(Y[:,t,ii],ET[:,t+1])
            end
        end

        return KeyedArray(Y[var_idx,:,shock_idx];  Variables = T.var[var_idx], Period = 1:periods, Shock = T.exo[shock_idx])
    end

    # return Y[var_idx,:,shock_idx]
end



function girf(state_update::Function, T::timings; 
    periods::Int = 40, 
    shocks::Symbol_input = :all, 
    variables::Symbol_input = :all, 
    negative_shock::Bool = false, 
    warmup_periods::Int = 100, 
    draws::Int = 50, 
    iterations_to_steady_state::Int = 500)

    shock_idx = parse_shocks_input_to_index(shocks,T)

    var_idx = parse_variables_input_to_index(variables, T)

    Y = zeros(T.nVars,periods,T.nExo)

    initial_state = zeros(T.nVars)

    for warm in 1:iterations_to_steady_state
        initial_state = state_update(initial_state, zeros(T.nExo))
    end

    for ii in shock_idx
        for draw in 1:draws
            for i in 1:warmup_periods
                initial_state = state_update(initial_state, randn(T.nExo))
            end

            Y1 = zeros(T.nVars, periods)
            Y2 = zeros(T.nVars, periods)

            baseline_noise = randn(T.nExo)

            shock = zeros(T.nExo)

            shock[ii] = negative_shock ? -1 : 1

            shock += baseline_noise

            Y1[:,1] = state_update(initial_state, baseline_noise)
            Y2[:,1] = state_update(initial_state, shock)

            for t in 1:periods-1
                baseline_noise = randn(T.nExo)

                Y1[:,t+1] = state_update(Y1[:,t],baseline_noise)
                Y2[:,t+1] = state_update(Y2[:,t],baseline_noise)
            end

            Y[:,:,ii] += Y2 - Y1
        end
        Y[:,:,ii] /= draws
    end
    
    # return Y[var_idx,:,shock_idx]
    return KeyedArray(Y[var_idx,:,shock_idx];  Variables = T.var[var_idx], Period = 1:periods, Shock = T.exo[shock_idx])

end

function parse_variables_input_to_index(variables::Symbol_input, T::timings)
    if variables == :all
        return indexin(T.var,sort(union(T.var,T.aux,T.exo_present)))
    elseif variables isa Matrix{Symbol}
        if !issubset(variables,T.var)
            return @warn "Following variables are not part of the model: " * string.(setdiff(variables,T.var))
        end
        return getindex(1:length(T.var),convert(Vector{Bool},vec(sum(variables .== T.var,dims= 2))))
    elseif variables isa Vector{Symbol}
        if !issubset(variables,T.var)
            return @warn "Following variables are not part of the model: " * string.(setdiff(variables,T.var))
        end
        return getindex(1:length(T.var),convert(Vector{Bool},vec(sum(reshape(variables,1,length(variables)) .== T.var,dims= 2))))
    elseif variables isa Tuple{Symbol,Vararg{Symbol}}
        if !issubset(variables,T.var)
            return @warn "Following variables are not part of the model: " * string.(setdiff(variables,T.var))
        end
        return getindex(1:length(T.var),convert(Vector{Bool},vec(sum(reshape(collect(variables),1,length(variables)) .== T.var,dims= 2))))
    elseif variables isa Symbol
        if !issubset([variables],T.var)
            return @warn "Following variable is not part of the model: " * string(setdiff([variables],T.var)[1])
        end
        return getindex(1:length(T.var),variables .== T.var)
    else
        return @warn "Invalid argument in variables"
    end
end





function parse_shocks_input_to_index(shocks::Symbol_input, T::timings)
    if shocks == :all
        shock_idx = 1:T.nExo
    elseif shocks == :none
        shock_idx = 1:T.nExo
    elseif shocks == :simulate
        shock_idx = 1
    elseif shocks isa Matrix{Symbol}
        if !issubset(shocks,T.exo)
            return @warn "Following shocks are not part of the model: " * string.(setdiff(shocks,T.exo))
        end
        shock_idx = getindex(1:T.nExo,convert(Vector{Bool},vec(sum(shocks .== T.exo,dims= 2))))
    elseif shocks isa Vector{Symbol}
        if !issubset(shocks,T.exo)
            return @warn "Following shocks are not part of the model: " * string.(setdiff(shocks,T.exo))
        end
        shock_idx = getindex(1:T.nExo,convert(Vector{Bool},vec(sum(reshape(shocks,1,length(variables)) .== T.exo,dims= 2))))
    elseif shocks isa Tuple{Symbol, Vararg{Symbol}}
        if !issubset(shocks,T.exo)
            return @warn "Following shocks are not part of the model: " * string.(setdiff(shocks,T.exo))
        end
        shock_idx = getindex(1:T.nExo,convert(Vector{Bool},vec(sum(reshape(collect(shocks),1,length(variables)) .== T.exo,dims= 2))))
    elseif shocks isa Symbol
        if !issubset([shocks],T.exo)
            return @warn "Following shock is not part of the model: " * string(setdiff([shocks],T.exo)[1])
        end
        shock_idx = getindex(1:T.nExo,shocks .== T.exo)
    else
        return @warn "Invalid argument in shocks"
    end
end





function parse_algorithm_to_state_update(algorithm::Symbol, ùìÇ::‚Ñ≥)
    if :linear_time_iteration == algorithm
        state_update = ùìÇ.solution.perturbation.linear_time_iteration.state_update

    elseif algorithm ‚àà [:dynare, :riccati, :first_order]
        state_update = ùìÇ.solution.perturbation.first_order.state_update

    elseif :second_order == algorithm
        state_update = ùìÇ.solution.perturbation.second_order.state_update

    elseif :third_order == algorithm
        state_update = ùìÇ.solution.perturbation.third_order.state_update
    end

    return state_update
end


function calculate_covariance(parameters::Vector{<: Number}, ùìÇ::‚Ñ≥)
    jacc = calculate_jacobian(parameters,ùìÇ)

    sol = calculate_first_order_solution(jacc; T = ùìÇ.timings)

    A = sol[:,1:ùìÇ.timings.nPast_not_future_and_mixed] * ‚Ñí.diagm(ones(ùìÇ.timings.nVars))[ùìÇ.timings.past_not_future_and_mixed_idx,:]
    C = sol[:,ùìÇ.timings.nPast_not_future_and_mixed+1:end]

    covar_dcmp = sparse(‚Ñí.triu(reshape((‚Ñí.I - ‚Ñí.kron(A, conj(A))) \ reshape(C * C', prod(size(A)), 1), size(A))))

    droptol!(covar_dcmp,eps(Float64))

    return covar_dcmp
end




function calculate_kalman_filter_loglikelihood(ùìÇ::‚Ñ≥, data::AbstractArray{Float64}, observables::Vector{Symbol}; parameters = nothing)
    if length(observables) != size(data)[1]
        @error "Data columns and number of observables are not identical. Make sure the data contains only the selected observables."
    end
    
    if length(observables) > ùìÇ.timings.nExo
        @error "Cannot estimate model with more observables than exogenous shocks. Have at least as many shocks as observable variables."
    end
    
    jacc = calculate_jacobian(isnothing(parameters) ? ùìÇ.parameter_values : parameters,ùìÇ)

    sol = calculate_first_order_solution(jacc; T = ùìÇ.timings)

    observables_and_states = sort(union(ùìÇ.timings.past_not_future_and_mixed_idx,indexin(observables,ùìÇ.var)))

    A = sol[observables_and_states,1:ùìÇ.timings.nPast_not_future_and_mixed] * ‚Ñí.diagm(ones(length(observables_and_states)))[indexin(ùìÇ.timings.past_not_future_and_mixed_idx,observables_and_states)
    ,:]
    B = sol[observables_and_states,ùìÇ.timings.nPast_not_future_and_mixed+1:end]

    C = ‚Ñí.diagm(ones(length(observables_and_states)))[indexin(sort(indexin(observables,ùìÇ.var)),observables_and_states),:]

    ùêÅ = B * B'

    T = size(data)[2]

    # Gaussian Prior
    P = reshape((‚Ñí.I - ‚Ñí.kron(A, A)) \ reshape(B * B', prod(size(A)), 1), size(A))
    u = zeros(length(observables_and_states))
    z = C * u
    
    loglik = 0.0

    for t in 1:T
        v = data[:,t] - z

        F = C * P * C'

        loglik += log(max(eps(Float64),‚Ñí.det(F))) + v' / F * v

        K = P * C' / F

        P = A * (P - K * C * P) * A' + ùêÅ

        u = A * (u + K * v)
        
        z = C * u 
    end
    return -(loglik + length(observables) * log(2 * 3.141592653589793) * T) / 2 # otherwise conflicts with model parameters assignment
end



end